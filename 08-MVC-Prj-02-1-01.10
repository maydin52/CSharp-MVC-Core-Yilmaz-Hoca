
Kitap Projesi
-------------
*** MVC Core 6
*** EF Core
*** 1-1, 1-M , M-M ilişkiler 
*** Identity ile uyelik Sistemi - Roller
*** Fluent API kullanımı
*** Custom Validations
*** Area Kullanımı


Book(BookID, BookName, Price, ReleaseDate, CoverImage,CategoryID)
Author (AuthorID,AuthorName, AuthorLastName)
BookAuthor(BAID, BookID,AuthorID)
AuthorDetail(AuthorDetailID,BirthDate, Region, Biography)
Category(CategoryID, CategoryName)

Islem Basamaklari
*** Identity sistemini olustur...
*** BookDB Tasarla...
*** Modlleri olustur...
*** Context sınıfndak propertyleri belirle...
*** Navigation Property'leri olustur...

-----------------

Kapsamı;
- Identity kullanımı
- Bire çok, bire bir, çoka çok kullanımı
- uzantısı sadece jpg olan örneğin yükleme
- custom validation yazımı
- ForeignKey annotaion kullanım zorunluluğu nerede, ne için?


Microsoft Identity seçeneği farklı. Araştır.

Yapay zeka çeşitleri;
Supervise sistemler (gpt vs. milyonlarca yazılımcı gpt vb sorarak sistemi geliştiriyor sonrasında öğrenince proramcıya gerek kalmayacak) ve unsupervise sistemler

------------------

Uygulama;

1. Create New Project - ASP.NET Core Web App(MVC) - Next - MVC_BookApp - Next - Authotantication Type : Individual Accounts ve HTTPS kliğini kaldır - Create

----------------------------------------

2. Area, Identity gibi klasörleri yeni eklemiş.
Data klasörü altında Migration ve Context i kendisi oluşturmuş ama dikkat DbContextten gelmiyor IdentityDbContext ten geliyor. IdentityDbContext de DbContextten geliyor. Go to definition bkz. Arada bir sürü generic sınıf var.
Package altında eklentileri kurmuş.
Migration klasörü içindeki classta Up ve Down var. Down içindekiler özet. AspNetRoles tablosu vs. 7 tane yeni tablo oluşturuyor üyelik sistemiyle alakalı ve çoğunu çoka çok ilişkiyle tutuyor. 
Appsettings.json dosyasında connection stringsi de yazmış. Kendimize uyarlayacağız sadece. Connection strings yazılışının birçok yazım şekli var. 
Burada özel kullanım; (localdb) kavramı; sql servere ihtiyaç duymadan da çalışılabiliyor ama çoklu bağlantılarda yavaş. 2010 gibi geldi.
localdb vs kapatıldığında uçmuyor. users içinde mdf ve log dosyası.
localdb ye msms olmadan vs içinden tools - connect to database - change - sql server database file seçilecek - Ok - path 
2-3 yıl önce yeni gelen özellikle artık memory de sql server gibi kullanma özelliği gelmiş ama aç kapa gitti. memory sql diye geçiyor.
SQL de bir değişiklik yaptın diyelim migration da bu yoksa sıkıntı. Migration üzerinden gitmek en doğrusu.

----------------------------------------

3. Migration ve identity tablolarının oluşturulması
nuget console
update-database
sql içndeki dabase içinde 7 tablo oluştu.

----------------------------------------

4. Modellerin oluşturulması
Tablolar ve alanlar belirlendi. İLŞKİNİN ADINI DOĞRU KOYMAK GEREKİYOR. YOKSA GÖMLEĞİN DÜĞMELERİ YANLIŞ İLİKLENMESİ GİBİ. 
Tablolar arası ilişkiler belirlendi. Kullanıcının detayı görmesi gerekli değilse join maliyeti oluşmamalı.
DİREKT KODLAYARAK BAŞMALAMK YANLIŞ. VERİTABANI TASARIMI ÖNCE KAĞIT ÜZERİNDE TASARLANIR VE ONAYLANIR SONRA KODLANMAYA BAŞLANIR.


    public class Author
    {
        public int AuthorID { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }

        [NotMapped]
        public string FullName { get => FirstName + " " + LastName; }

        public AuthorDetail? AuthorDetail { get; set; }
        public ICollection<BookAuthor>? AuthorBooks { get; set; }
    }



    public class AuthorDetail                      //BAŞKA BİR PROP FK OLMASINI İSTESEYDİK ONUN ÖNÜNE YAZACAKTIK.
    {
        [ForeignKey("Author")]                    //DİKKAT!!! HEM PK HEM FK       BİREBİR İLİŞKİDE BİR TARAF MUTLAKA FK OLMALI. PK OLDUĞUNDAN FK EKLEDİK.      VERİLEN İSMİN ÖNEMİ YOK.
        public int AuthorDetailID { get; set; }      //SQL DEN KEYS İÇİNDEN KONTROL ETTİK. HEM PK HEM FK OLARAK GÖRÜNÜYOR.
        public DateTime  BirthDate { get; set; }
        public string Region { get; set; }
        public string Biography { get; set; }


        public Author? Author { get; set; }
    }



    public class Book
    {
        public int BookID { get; set; }
        public string BookName { get; set; }
        public DateTime ReleaseDate { get; set; }
        public string CoverImagePath { get; set; }
        
        [NotMapped]
        public IFormFile CoverImage { get; set;}
        public decimal Price { get; set; }

        public int CategoryID { get; set; }


        public Category? Category { get; set; }
        public ICollection<BookAuthor>? BookAuthors  { get; set; }
    }




    public class BookAuthor
    {
        [Key]                                            //BAID Yİ EF ANLAMAYACAĞI İÇİN PK OLARAK TANIMLADIK
        public int BAID { get; set; }
        public int BookID { get; set; }
        public int AuthorID { get; set; }

        public Book? Book { get; set; }
        public Author? Author { get; set; }
    }




    public class Category
    {
        public int CategoryID { get; set; }
        public string CategoryName { get; set; }

        public ICollection<Book>? Books { get; set; }
    }

------------------------------------------------------------------------

5. Context sınıfındaki propertyleri belirledik.
Aşağıda DbSet propertyleri ekledik. Üsttekiler otomatik gelmişti.

    public class ApplicationDbContext : IdentityDbContext<AppUser>            //DIKKAT!!! <AppUser>  ekledik. standardın dışına çıkıldığı için.
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options)
        {
        }

        public DbSet<Book> Books { get; set; }
        public DbSet<Category> Categories { get; set; }
        public DbSet<Author> Authors { get; set; }
        public DbSet<BookAuthor> BooksAuthors { get; set; }            //ÇOKA ÇOK İLİŞKİ TABLOSUNUN İSMİNE DİKKAT
        public DbSet<AuthorDetail> AuthorDetails { get; set; }

        public DbSet<AppUser> Users { get; set; } 
    }

--------------------------------------------------------------------------

6. DB de AspNetUsers tablosunun özelliklerine baktık ve Id nin tipinin string nvarchar(450) ve PK olduğunu gördük. Oraya GUID oluşturuyor amagenellikle biz onu int çevirmek isteriz. 
Kolay kullanılacaksa birşey yapılmasına gerek yok ama burada bir customization yapacaksak birşeyleri değiştirmemiz gerekecek.
Zahidin verdiği örneğe göre adamın querystringden oynayabilmesini engellemek gerekir. Url rewriting konusu var ARAŞTIR.
Bu tablo aynı zamanda indexleneceği için ve aynı zamanda PK da olacağı için int değerlerde yani tam sayı değerlerde arama hızı çok yüksek, string ifadelerde daha yavaş.
MS in string verme sebeplerinde biri de bize özelleştirme imkanı sağlıyor. Int verseydi stringe dönüştürmek daha zor olurdu. String herşeyi alabildiğinden.

Çalıştırdığımızda sağ tarafta Register ve Login butonları çıktı. Burada standart validasyon işlemlerinin özellikleri bulunduruyor.
E-mail göndereblmek için bir smtp servera ihtiyaç var.
Uygulama üzerinde kullanıcı oluşturduk ve db tabloda oluşan kayıdı kontrol ettik.
DİKKAT!!! username ile e-mail aynı. MS varsayılan böyle kabul etmiş.
Login sayfasının cshtml i gizli (Düz MVC de açık). Gelenler DLL içinden geliyor. Register ve Login ekranlarının görüntüsü yok. Nasıl değiştireceğiz? 3. Örnekte sil baştan biz yazacağız. Çünkü classları var.
Proje üzerinde sağ tık - Add - New Scaffolded Item - Soldaki Identity seç - Identity seç - Add - şimdilik login logut ve register seçtik - context sınıfı seç - Add
IDENTITY - PAGES ALTINDA ACCOUNT KLASÖRÜ OLUŞTU VE CS.HML LERİ GELDİ. BURASI MVC GELMİYOR. RAZOR PAGES OLARAK GEÇİYOR. BURADA CONTROLLER YOK. HER BİRİNİN ALTINDA CS DOSYALARI VAR.
MVC CORE DA SADECE MVC CORE İLE DEĞİL RAZOR PAGE UYGULAMASIYLA DA UYGULAMA GELİŞTİRİLEBİLİYOR. WEB FORM KULLANIMININ BENZERİ.

program.cs içinde Add service to the container altındakileri bir önceki projede biz yazmıştık. Onları da şimdi otomatik yazmış.
Birincisi DbContext ayarı
İkincisi Identity ayarı
Biz özelleştirme yapacağımız için bunları yoruma aldık.

Özelleştirmelerden biri;
AspNetUsers tablosunda ad, soyad ve adres bilgisi yok mesela. Bu tabloda olmayan bir verinin bu tabloda tutulması isteniyorsa;
6.a IdentityUser sınıfından miras alarak yeni bir sınıf oluşturuyoruz ve propertylerini ekliyoruz.

public class AppUser:IdentityUser
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public string Address { get; set; }
    }
6.b Context sınıfına DbSet ekliyoruz.

public DbSet<AppUser> Users { get; set; } 

6.c Program.cs te aşağdaki değişiklikleri yapıyoruz.
Başka birçok değişiklikler de yapabiliyoruz.


// Add services to the container.
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(connectionString));
builder.Services.AddDatabaseDeveloperPageExceptionFilter();

//AppUser=> IdentityUser Yerine Kullanılacak...
builder.Services.AddDefaultIdentity<AppUser>(options => { 
    
    options.SignIn.RequireConfirmedAccount = false;
    options.Password.RequiredLength = 7;
})
    .AddEntityFrameworkStores<ApplicationDbContext>();

//Standart şekilde kullanılacaksa...
//builder.Services.AddDefaultIdentity<IdentityUser>(options => options.SignIn.RequireConfirmedAccount = true)
//    .AddEntityFrameworkStores<ApplicationDbContext>();

builder.Services.AddControllersWithViews();


6.d Views - Shared - _LoginPartial içinde en üstteki inject ler aşağıdaki gibi değiştirildi. <IdentityUser> vardı daha önce.

@inject SignInManager<AppUser> SignInManager
@inject UserManager<AppUser> UserManager


6.e Migration oluşturuyoruz.


6.f DB içerisinden tabloyu kontrol ediyoruz.


-----------------------------------------------------------------------------------------
09-MVC-Prj-02-2-07.10





1. Area - Identity - Pages - Account - Register.cshtml içine, AppUser modeline eklenen özellikleri buraya ekleyeceğiz. Razor Pages yaklaşımı. MVC paterni veya patern yok. Düz MVC de de var.
Register.cshtml içindeki Input modelleri aşağıdaki şekilde bağlıyoruz; Standardın dışına çıktığımız için bu konuya girdik.
Yazılım geliştirme süreçleri çok maliyetli.
%80 kopya döndüğü için çok farketmiyoruz belki ama.


1.a Register.cshtml.cs içinde InputModel classı içine aşağıdakileri ekledik.
DİKKAT!!! ErrorMessage içini boş brakırsan hata alırsın.

public class InputModel
{
            [Required]
            [Display(Name = "FirstName")]
            public string FirstName { get; set; }

            [Required]
            [Display(Name = "LastName")]
            public string LastName { get; set; }

            [Required]
            //[MinLength(10, ErrorMessage =""),MaxLength(200,ErrorMessage ="")]
            [Display(Name = "Address")]
            public string Address { get; set; }



1.b Register.cshtml içinde form tagi altına aşağıdakileri ekledik.



            <h2>Create a new account.</h2>
            <hr />
            <div asp-validation-summary="ModelOnly" class="text-danger"></div>


            <div class="form-floating">
                <input asp-for="Input.FirstName" class="form-control"  aria-required="true" />
                <label asp-for="Input.FirstName"></label>
                <span asp-validation-for="Input.FirstName" class="text-danger"></span>
            </div>

            <div class="form-floating">
                <input asp-for="Input.LastName" class="form-control"  aria-required="true" />
                <label asp-for="Input.LastName"></label>
                <span asp-validation-for="Input.LastName" class="text-danger"></span>
            </div>

            <div class="form-floating">
                <input asp-for="Input.Address" class="form-control" aria-required="true" />
                <label asp-for="Input.Address"></label>
                <span asp-validation-for="Input.Address" class="text-danger"></span>
            </div>


1.c Register.cshtml.cs içinde user. ile başlayan propertyler eklenmeden önce aşağıdaki kontrol yapıldı.
DİKKAT!!!

Program.cs içindeki aşağıda yazılı olan yazı içindeki RequireConfirmedAccount = false; olduğundan emin olduk.
//AppUser=> IdentityUser Yerine Kullanılacak...
builder.Services.AddDefaultIdentity<AppUser>(options => { 
    
    options.SignIn.RequireConfirmedAccount = false;
    options.Password.RequiredLength = 7;
})
    .AddEntityFrameworkStores<ApplicationDbContext>();


Daha sonra; Register.cshtml.cs içinde user. ile başlayan propertyler eklendi.

        public async Task<IActionResult> OnPostAsync(string returnUrl = null)
        {
            returnUrl ??= Url.Content("~/");
            ExternalLogins = (await _signInManager.GetExternalAuthenticationSchemesAsync()).ToList();
            if (ModelState.IsValid)
            {
                var user = CreateUser(); altına

                user.FirstName = Input.FirstName;
                user.LastName=Input.LastName;
                user.Address = Input.Address;




1.d Register.cshtml.cs içinde yorum satırına alındı. Mail gönderme ile ilgili kod.

                    //var code = await _userManager.GenerateEmailConfirmationTokenAsync(user);
                    //code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));
                    //var callbackUrl = Url.Page(
                    //    "/Account/ConfirmEmail",
                    //    pageHandler: null,
                    //    values: new { area = "Identity", userId = userId, code = code, returnUrl = returnUrl },
                    //    protocol: Request.Scheme);

                    //await _emailSender.SendEmailAsync(Input.Email, "Confirm your email",
                    //    $"Please confirm your account by <a href='{HtmlEncoder.Default.Encode(callbackUrl)}'>clicking here</a>.");

Oturum yapıp yapamayacağımızın testini yaptık. Yeni kullanıcı oluşturduk ve griş yaptık.

-----

2. SQL içinden tablolardaki tipleri kontrol ettik ve değiştirilmesi gerekenleri gördük.

Context sınıfında ilişki ve ilk değer atamalarını yaptık.

protected override void OnModelCreating(ModelBuilder builder)
        {
            base.OnModelCreating(builder);

            //Tum entitylerin ozellikleri buradan verilebilinir...


            builder.Entity<Category>().Property(x => x.CategoryName)
                                      .IsRequired()
                                      .HasMaxLength(30)
                                      .HasColumnType("varchar");
            
            //ilk deger atama....
            builder.Entity<Category>().HasData(
                new Category { CategoryID=1, CategoryName="Roman" },
                new Category { CategoryID=2, CategoryName="Hikaye" },
                new Category { CategoryID=3, CategoryName="Deneme" }
                );


            builder.Entity<Book>().Property(x => x.BookName).IsRequired().HasMaxLength(150).HasColumnType("varchar");
            builder.Entity<Book>().Property(x => x.CoverImagePath).IsRequired().HasMaxLength(30).HasColumnType("varchar");
            builder.Entity<Book>().Property(x => x.ReleaseDate).IsRequired(false).HasColumnType("smalldatetime");
            builder.Entity<Book>().Property(x => x.Price).IsRequired().HasColumnType("money");
            
        }

- Migration oluşturduk.

------

3. Admin için Area oluşturacağız. Çünkü admin sayfası son kullanıcınınkinden farklı olmalı. CRUD veya kontrol paneli gibi.
Identity için kendisi zaten oluşturmuştu. Biz Admin için olşuturacağız.
Projeyi fiziksel ve mantıksal olarak ayırıyor. Area ların kendi mvc leri var.

3.a Solution ağacının en üstünde sağ tık - Add - New Scaffolded Item - Sol taraftan Common seç - ortadan MVC Area seç - Add - isim ver AdminPanel - Add
Çıkan kodu kopyala. Kodu kaybedersen ağaçta altta txt dosyası içinde.

3.b Program.cs içinde app.MapControllerRoute( gerisine yapıştır.
Bu olmadan sayfaya ulaşılamazdı, denedik.


Bu area altından aşağıdaki controlleri oluşturduk.

    [Area("AdminPanel")]    //DİKKAT!!! BUNU YAZMAYI UNUTMA. DÜZ MVC DE BU YOK. DÜZ MVC DE KODUN BAŞINDA SESSION VAR MI YOK MU DİYE KONTROL EDİLİYOR. ORADAN GÖNDERİLİYOR. 
                            //DİKKAT!!! CLASSIN TEPESİNE YAZILACAK.
    public class PanelController : Controller
    {
        public IActionResult Index()
        {
            return View();
        }
    }

Bu controllerin view ini oluşturduk.

<h1>Admin Panel Sayfasi....</h1>

<ul>
    <li><a asp-area="AdminPanel" asp-controller="Categories" asp-action="Index">Kategoriler</a></li>
    <li>Kitaplar</li>
    <li>Yazarlar</li>
</ul>

DİKKAT!!! LAYOUT GELMEDİ. AREA ALTINDAKİ IDENTITY ALTINDAKİ _ViewImports.cshtml ve _ViewStart.cshtml DOSYALARINI KOPYALAYIP ADMINPANEL İÇİNDEKİ VIEWS KLASÖRÜNE EKLE. ALT KLASÖRLERİNDE OLMAYACAK.

-----

4. Yukarıdaki  Index.cshtml üzerinde sağ tık scaffold controller oluşturduk. Model Category ve CategoriesController isminde.
Kendisi koydu ilk attribute ü.

    [Area("AdminPanel")]
    public class CategoriesController : Controller
    {
        private readonly ApplicationDbContext _context;

        public CategoriesController(ApplicationDbContext context)
        {
            _context = context;
        }

        // GET: AdminPanel/Categories
        public async Task<IActionResult> Index()
        {
              return _context.Categories != null ? 
                          View(await _context.Categories.ToListAsync()) :
                          Problem("Entity set 'ApplicationDbContext.Categories'  is null.");
        }

        // GET: AdminPanel/Categories/Details/5
        public async Task<IActionResult> Details(int? id)
        {
            if (id == null || _context.Categories == null)
            {
                return NotFound();
            }

            var category = await _context.Categories
                .FirstOrDefaultAsync(m => m.CategoryID == id);
            if (category == null)
            {
                return NotFound();
            }

            return View(category);
        }

        // GET: AdminPanel/Categories/Create
        public IActionResult Create()
        {
            return View();
        }

        // POST: AdminPanel/Categories/Create
        // To protect from overposting attacks, enable the specific properties you want to bind to.
        // For more details, see http://go.microsoft.com/fwlink/?LinkId=317598.
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Create([Bind("CategoryID,CategoryName")] Category category)
        {
            if (ModelState.IsValid)
            {
                _context.Add(category);
                await _context.SaveChangesAsync();
                return RedirectToAction(nameof(Index));
            }
            return View(category);
        }

        // GET: AdminPanel/Categories/Edit/5
        public async Task<IActionResult> Edit(int? id)
        {
            if (id == null || _context.Categories == null)
            {
                return NotFound();
            }

            var category = await _context.Categories.FindAsync(id);
            if (category == null)
            {
                return NotFound();
            }
            return View(category);
        }

        // POST: AdminPanel/Categories/Edit/5
        // To protect from overposting attacks, enable the specific properties you want to bind to.
        // For more details, see http://go.microsoft.com/fwlink/?LinkId=317598.
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Edit(int id, [Bind("CategoryID,CategoryName")] Category category)
        {
            if (id != category.CategoryID)
            {
                return NotFound();
            }

            if (ModelState.IsValid)
            {
                try
                {
                    _context.Update(category);
                    await _context.SaveChangesAsync();
                }
                catch (DbUpdateConcurrencyException)
                {
                    if (!CategoryExists(category.CategoryID))
                    {
                        return NotFound();
                    }
                    else
                    {
                        throw;
                    }
                }
                return RedirectToAction(nameof(Index));
            }
            return View(category);
        }

        // GET: AdminPanel/Categories/Delete/5
        public async Task<IActionResult> Delete(int? id)
        {
            if (id == null || _context.Categories == null)
            {
                return NotFound();
            }

            var category = await _context.Categories
                .FirstOrDefaultAsync(m => m.CategoryID == id);
            if (category == null)
            {
                return NotFound();
            }

            return View(category);
        }

        // POST: AdminPanel/Categories/Delete/5
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteConfirmed(int id)
        {
            if (_context.Categories == null)
            {
                return Problem("Entity set 'ApplicationDbContext.Categories'  is null.");
            }
            var category = await _context.Categories.FindAsync(id);
            if (category != null)
            {
                _context.Categories.Remove(category);
            }
            
            await _context.SaveChangesAsync();
            return RedirectToAction(nameof(Index));
        }

        private bool CategoryExists(int id)
        {
          return (_context.Categories?.Any(e => e.CategoryID == id)).GetValueOrDefault();
        }
    }

-----
-----------------------------------------------------------------------------------------







