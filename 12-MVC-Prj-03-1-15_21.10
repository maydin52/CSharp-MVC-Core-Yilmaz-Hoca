
MVVM(Model View ViewModel)  //DESKTOP TİPİ UYGULAMALAR İÇİN KULLANILIR. WEB İÇİN UYGUN DEĞİL.

Webforms tan MS desteğini 2019 da kaldırdı. Yerine Razor Pages geldi. 2001-2002 yılında başlamıştı. Şuan piyasada çok var da yavaş yavaş core a geçecekler. Düz MVC. 
*.aspx dosyaları => web forms uygulamalarıdır...
Backend front end olarak geçmiyor. Tek sayfada yazılıyor. Webform örneği yapmıştık.
NVC olmadığı için herşey tek sayfada. Bind<%
Düz MVC wizardı iyiydi. Minimum kodla yazılıyordu.
Uzun vadede maintenance zor ve yaşam çalışıyordu. 

Bir Web Uygulaması iki şekilde geliştirilebilir..
MVC(Model View Controller)
Razor Pages (DİKKAT MVC PATERNİ YOK AMA YÖNETMESİ MVC DEN DAHA ZOR.)

---------------------

Katmana neden ihtiyaç var?
Bir uygulama isteniyor fakat sonra patron geldi biz bu projeyi başka bir firmaya daha satacağız, fakat bu adamlar oracle da çalışıyor dedi.
Ne yapacağız? Katman yok. Uygulamanın heryerine yayılış vaziyette.

Ya da bu projeyi sattık, adamlar ağ kullanmadan kullanmak isteyirlar, windows projesi olarak hemde. 
Ne yapacağız? Katman yok. HTML CSS JS controllerlar, aksiyonlar ne olacak?
Veya önceden düz MVC yazmış, core a geçecek. Katmanlı yaptıysa DAL değişecek sadece.

Katman sayısı arttıkça bürokrasi artıyor.
Bürokrasi arttıkça sistem yavaşlıyor.

Adamın ihtiyacını doğru tespit etmek çok öenmli.
İhtiyacı olmayana fazlasını vermemek gerek.
Başlangıçta gidişatı iyi kestirmek, tedbiri ona göre almak gerekiyor. 
Katmanlıda işçilik maliyet artıyor ama uzun vadede kazanım oluyor. Yarın adam biz oracle a geçiyoruz dediğinde projeyi elden geçirmemek için.
Adamla baştan herşeyi konuşmak ve avukat aracılığyla ve hukuksal kriterlere dikkat ederek sözleşme yapmak lazım.

Katmanlı Mimari (n-Layer, n-Tier)  //Genellikle aynı gibi kullanılıyor ama katmanlar aynı bilgisayardaysa Layer, herbiri farklı bilgisayardaysa Tier olarak geçer.
Tarihçesi network tarihçesiyle aynı. 1960 lara dayanıyor.
Servislerde bir katmandır.

Genelde kullanılan katmanlar;
DAL (Data Access Layer)      //sadece veriyi alıp bana göndermek ya da benden veri alıp db ye eklemek yani al - ver.
BLL (Business Logic Layer)     //yapılan işlerle ilgili raporlar, hesaplamalar, iş mantıkları
PL  (Presentation Layer)    //Ortam bağımsızlığı konusu.

Hocanın çizdiği şema şöyle;

DAL <-> BLL <-> PL <---> DB

  DAL-BLL-PL BAĞLI
     M O D E L   veya   E N T I T Y


Katmanlar birbirlerini geçip ilerleyemez. Birbirleri üzerinden iletişim kurarlar. OSI layerda da öyle.
Onion daha esnek, böyle değil. Kümülatif olarak toplaya toplaya içine ala ala gider. Soğanın içindeki katmanlar gibi. Cücük Core yani Domain.
Bu normal katmanlı mimarideki sorunları da çözüyor.
Küçük projelerde katmanlıya gerek olmayabilir. Bazen bazı katmanlardan direkt geçmek isteyebiliyoruz.

Örneğin; web de OSI LAYER 

Katmanli Mimari; Bir projeyi daha iyi yönetebilmek için mantıksal ve fiziksel olarak 
         birbirinden ayırmak veya parçalara ayırmak için kullanılır...

Mesela yeni bir model tanımlanacak, adam nereye bakacağını biliyor.
Mesela adam dedi yeni bir rapor ekleyeceğim. Yazacağım yer belli. Ön yüze yazmıyorum.

*** N.S.A. Her katman birbirinden bagimsiz olmalı... Katmanlar arası bağımlılık olmamalı.

Bir standarda göre yazılması gerekiyor.

Katmanlar DLL dosyalarıyla ayrılırlar. Fakat birbirleriyle bağlantıları var. Ama bir taraftanda birbirinden bağımsız. SQL çıkarıp Oracle taktığında çalışmasına devam etmeli.
Eğer etmiyorsa bu katmanlı mimari değildir.

Repository katmanı DAL ve BLL arasında olur. Onion da Infrastructure da.
Repository depo demek. 
Bazen sql de bazen oracle da ya da mysql dede tutabiliyor. Örneğin arge de farklı, satışta farklı db gibi. Önceden başlamıştır çalışıyordur dokunmamışlardır gibi.
Neden önemli? Bazen öyle bazen böyleyse Kimin neyi çalıştıracağına Repository üzerinden karar veriliyor. Yani bazen SQL DAL bazen Oracle DAL çalışıyor gibi.

API de PL ile BLL arasında bir yerde.
API MVC altyapısını kullanır ama View yoktur. Yani kullanıcıya View gitmez, data gider. Buradaki View string ama JSON veya XML veya CSV data olarak gidiyor ama istek geldiğinde 
yine DAL dan geçmesi gerekir. İstek PL üzerinden gelmeyecekse, dış dünyadan bir yerden geliyorsa BLL ve DAL dan veriyi getirip JSON döndüm yani PL kullanılmadı. Adam ö yüzde
istediği gibi kullansın. Bu mantık genelde B to B uygulamalarında ya da SPA Single Page Application da kullanılır. SPA de ön yüzde sadece bir sayfa vardır. Tek sayfadan oluştur.
Adam önyüzde ekranını sadece HTML CSS JS REACT ANGULAR VUEJS vs kullanarak oluşturuyor ve servis üzerinden veriyi çekiyor. 
Özellikle trendyol vs sitelerde dükkan açıyorsunuz. Kendiniz ürün ekliyorsunuz. Adamın veritabanına insert yapabilmek için connection string bilmem ve bana erişim olması lazım. 
Ama milyon adama bu veritabanı açılmaz. İşte servis mantığı burada devreye giriyor. Yine trendyol veritabanına ekliyor ama doğrudan değil, servis aracılığıyla.
Servis içindeki CRUD metodları da birbirinden farklı olabilir servis mantığı olmazsa. Adama ben sadece ekle metodunu açıyorum ve trendyola bu metod üzerinden gidiyor.
Eskiden metadata açılıyormuş. Servisin içindeki metodları görmesi gerekiyordu. Adam nereden bilecek. Birisi ekle der, birisi ürün ekle der, bilemez.
WCF servislerde meta datalar ne olduğunu, parametrelerini söyler. İmplement formatındadır, ekranda gösterir. 
Şimdi Restfulservislerde ona gerek kalmadı. Sadece servisin adresini bilmek yeterli. Çünkü 4 eylem var; put, post, delete, get. 
Siz sadece yapacağınız eylemi bunlar üzerinden gönderiyorsunuz, arkadaki metodun ismini bilmek zorunda değilsiniz.
Ekleme yapacaksan post, update yapacaksam put olarak göndermem yeterli. Kendisi arka planda bunu çözüyor. 
jwt.io günümüz servislerinin büyük ısmı güvenlik için bunu kullanıyor. Detayı önceki deslerde var.

------------------------

Örneğin katmanları yazmak için iş bölümü yapacağız;
1. Önceden modelin ve ilişkilerin kararlaştırılmış olması gerekiyor.
2. Mesela DAL yazılmadan BLL veya servisi yazacak adam birşey yapamaz. Belirli bir seviyeye kadar gelmesi gerekiyor. 
3. O seviyeye kadar ortak gidilir daha sonra görev planlamaları ayrılır.


İşi uzatıyor ama uzun vade yatırımı katmanlı mimari

------------------------

Doğrudan bir katmana ulaşamadığımız için; 
Normal katmanlıda her dll kendisinden bir öncesine ve bir sonrasına referans veriyor. Oysa Onion da kümülatif.
Kodlama maliyetlerini düşürüyor ve bazı problemleri daha azaltıyor.
Eskiden daha karmaşık yazdığımız uygulamaları daha az yazıyoruz. 

Bazen PL direkt DAL dan okumak istiyor. Böyle olunca boşu boşuna BLL de işyükü oluşuyor. 
İkisinde de katman sayısı arttıkça performans düşer ama biz bunu göze alıyoruz çünkü konu uzun vadede avantaj.
Aslında düz katmanlı yönteme en iyi uyan yöntem bağlantılı yöntemdir yani EF olmadan. O zaman cillop gibi.
DAL yazarken Ef bu katmana eklemek zorundayım. DAha sonra PL katmanında da DbContext sınıfını tanıması için EF yi Pl e ekleme zorunda kalıyoruz. 
Yani iki ayrı katmana EF ekledim. Oniondan önce katmanlı mimaride EF kullanılıyorsa katmanlı mimarin,n ruhuna aykırı işler yapılıyor. 
Yani her katman bağımsız olacaktı ama burada her iki katman da EF ye bağımlı. Oysa Onion da bu tip problemler çözülmüş. Core a Ef eklenirse kümülatif gittiğinden problem çözülmüş.

Onion Modelde ise ; tum katmanlar birbirine eklenenerek buyur... 2008 DE GELMİŞTİR. DİĞERİNE ZİYADE BU DAHA YÖNETİLEBİLİR.
Core(Domain) - yuvarlağın en merkezinde     // ENTITY
Infrastructure - bir sonraki çember içinde      // VERİYE ERİŞİM
Application - bir sonraki çember içinde    // O VERİYİ NASIL KODLAYACAKSINIZ BURADA KODLAMA YAPISI KARAR YAPILARI VS.
Presentation veya UI(User interface) - bir sonraki çember içinde - bu çember alanı da ayrı parçalara ayrılabiliyor. Bir kısmı MVC bir kısmı Windows gibi. // AL - VER GÜLÜM.
                                                                    //KULLANICIDAN VERİYİ ALACAK VE GÖNDERECEK SADECE. HERHANGİ BİR MANTIK YOK. MANTIK BİR ÖNCEKİNDE.

----------------------------------------------------------------------------------------------------------------------------------------------------

DLL OLUŞTURMA

1. Yeni Class Library açıyoruz. (Arama seçeneklerinden c# All platforms ve Library seç - ilk seçenek)

2. İlk çalışma için Matematik ismini verdik.
Dikkat!!! DLL dosyası direkt çalışmaz. Çünkü main yoktur. Exe dosyaya ihtiyaç var. O yüzden katmanları yazarken dikkatli gitmek gerek.

3. Matematik dosyası içinde class açtık.

public class Cebir
    {
        public int KareAl(int sayi)
        {
            return sayi * sayi;
        }
        public int Topla(int sayi1, int sayi2) 
        { 
            return sayi1 + sayi2;
        }

        public int KupAl(int sayi)
        {
            return sayi * sayi * sayi;
        }
    }

4. Yazdıktan sonra rebuild ediyoruz.

5. Open Folder in File Explorer - bin - debug - net6.0 içinde Matematik.dll dosyasının oluştuğunu göreceksin.

-------------

DLL DOSYAYI KONSOL UYGULAMASINDA KULLANMA
//Cebir DLL dosyasında daha sonra değişiklik yaptığında yansıyor.
//Hem de exe dosyanın olduğu yere de getiriyor.

1. Yeni Consol App açıyoruz.

2. proje üzerinde sağ tık - Add - Project Reference - Matematik seçeneğini klikle (içinde açık değilse browse ile dosya yolundan seç) - OK

3. Program.cs de aşağıdaki gibi çalıştırıyoruz.

using Matematik;

Cebir cebir = new Cebir();
Console.WriteLine(cebir.KareAl(4));
Console.WriteLine(cebir.Topla(4,5));
Console.WriteLine(cebir.KupAl(4));

---------------

DLL DOSYAYI WINDOWS UYGULAMASINDA KULLANMA
//Form1 açıkken sol üstte Form1 başlığı solundaki monitör logosu mavi ise .NET, siyah ise Core da açık demektir.

1. Yeni Windows Form App açıyoruz.

2. proje üzerinde sağ tık - Add - Project Reference - Matematik seçeneğini klikle (içinde açık değilse browse ile dosya yolundan seç) - OK

3. Form classı içerisinde aşağıdaki gibi çalıştırıyoruz.

        private void button1_Click(object sender, EventArgs e)
        {
            Cebir cebir = new Cebir();

            MessageBox.Show(cebir.KupAl(5).ToString());
        }

---------------
İLK PROJE DOSYASINI OLUŞTURMA

1. Visual Studio başlangıç ekranından Blak Solution seçiyoruz.
Solution Name : Hardware
Create

2. proje üzerinde sağ tık - add new item - txt dosyası oluşturulur. 

Projede Yapılacaklar;
*** Konu:Bilgisayar Parcalari
*** UI:MVC Core 6
*** Entity FrameworkCore
*** IEntityTypeConfiguration kullanımı...(FluentAPI)
*** Onion Katmanlı Modeli kullanılacak
*** Dll olusturma (Katmanlar icin)
*** Generic Repository kullanılacak...
*** Interface kullanılacak
*** Identity ile Uyelik sistemi(Admin,Rol)
*** AutoMapper kullanımı
*** Sepet ve Stok kullanımı...
*** 4-veya 5 tablo olacak
*** Identity kullanımında Idler int olmali...
*** Veritabindan silme islemi olmayacak...(Aktif/Pasif)
*** DTO(I,U), ViewModel(SELECT) 
    - ViewModel ; genelde select için kullanılır. Daha önce resim eklemek için kullandığımız IFormFile interface ini Application katmanında Viewmodelde kullanacağız. Çünkü önyüzle alakalı. Web projesinde böyle. Win form uygulamasında
ön yüz olayı olmadığından bu interface e gerek yok. 
    - DTO ; genellikle insert ve update için kullanılır. Örneğin insert yaparken id göndermemize gerek yok. 

Analiz: Hardware Project
 Product(ProductID, BrandID,CategoryID, Name, Price,Stock,ProductImage, Detail )
 Category(CategoryID, Name)
 Brand(BrandID, Name) 
 Model(ModelID, BrandID,CategoryID, ModelName) 
 ShoppingCart(ID, ProductID, Amount,UserID)
 Invoice(ID,UserID,Date, )
 InvoiceDetail(ID, InvoiceID, ProductID, Amount,Price )

 + IdentityTables




3. Proje üzerinde sağ tık - add - new project - class library - isimlendirmeye dikkat Hardware.Domain (Hardware.Core diyen de var) - Next - Create
Hardware.Domain altında Entities (veya Models de olur) adında yeni klasör açtık.
Class1 i sildik.




4. Nugetten Microsoft.AspNetCore.Identity.EntityFrameworkCore seçip, domain projesini seçip, versiyon seçip 6.0.23 yüklüyoruz.
AppUser:IdentityUser<int> vr AppUser:IdentityUser<int> için. Dikkat!!! önceden UserId varchar(250) idi, guid tutuyordu. Int çevireceğiz.
IdentityUser den türetmemiz gerektiği için bunu yaptık.
Bunu normal katmanlı mimaride yaptığınızda herşey birbirine giriyor. Katmanlar birbirinden bağımsız olmalıydı ama ben DAL ı EF ye bağlıyorum.
Onion da toplaya toplaya gittiği için oradan kurtarıyor.
Normal katmanlıda bu sefer her iki katmana da framework kurulması gerekiyor bu da bağımlılık oluşturuyor.



5. Entities klasörü içerisinde iki klasör daha oluşturduk; birisi Abstract diğeri Concrete.

5.a Abstract klasörü içerisine aşağıdaki interface ekledik;
Neden interface? Çünkü interface soyut bir yapıdır. Ramde karşılığı olmaz.
Id neden vermedik? EntityID tercih ediyoruz. AppUser ve AppRole tablolarından da ID gelecek. Sorun olacağı için eklemedik. Identity özelleştirmesi olmasaydı eklenebilirdi.
Loglama her tablo için olmasa da çok stratejik konularda ayrı tablolarda kaydedilir. Her tablo için olması; kapladığı alandan ziyade sunucu ile sürekli konuşması olumsuz performans.


public interface IBaseEntity
    {
        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }      //nullable
        public DateTime? PassiveDate { get; set; }    //nullable
        public Status Status { get; set; }
    }




5.b Concrete klasörü içerisine aşağıdaki interface ekledik;
- Neden Concrete? Çünkü Ramde karşılıkları olacak. Gerçekte olması gereken sınıfları yerleştiriyoruz.


    //IdentityRole go to definition ile varsayılan alanları incele.

    public class AppRole:IdentityRole<int>
    {

    }



    //IdentityUser go to definition ile varsayılan alanları incele.

    public class AppUser:IdentityUser<int>        //MS in tablosuna ilave ekstra istenilen alanlar
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public string Address { get; set; }

        public ICollection<Product>? Products { get; set; }
        public ICollection<Invoice>? Invoices { get; set; }

    }



    public class Brand:IBaseEntity
    {
        public int BrandID { get; set; }
        public string Name { get; set; }


        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        public ICollection<Model>? Models { get; set; }
        public ICollection<Product>? Products { get; set; }
    }



    public class Category:IBaseEntity
    {
        public int CategoryID { get; set; }
        public string Name { get; set; }


        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        public ICollection<Model>? Models { get; set; }
        public ICollection<Product>? Products { get; set; }
    }



    public class Invoice:IBaseEntity
    {
        public int InvoiceID { get; set; }
        public DateTime InvoiceDate { get; set; }

        public int AppUserID { get; set; }

        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        public AppUser? AppUser { get; set; }
        public ICollection<InvoiceDetail>? InvoiceDetails { get; set; }
    }



    public class InvoiceDetail:IBaseEntity
    {
        //ID, InvoiceID, ProductID, Amount,Price

        public int InvoiceDetailID { get; set; }
        public int InvoiceID { get; set; }
        public int ProductID { get; set; }
        public int Amount { get; set; }
        public decimal Price { get; set; }

        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        public Invoice? Invoice { get; set; }
        public Product? Product { get; set; }

    }



    public class Model:IBaseEntity
    {
        public int ModelID { get; set; }
        public string Name { get; set; }

        public int? BrandID { get; set; }
        public int? CategoryID { get; set; }

        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        public Brand? Brand { get; set; }
        public Category? Category { get; set; }

    }



    public class Product:IBaseEntity
    {
        public int ProductID { get; set; }
        public string Name { get; set; }

        public int? BrandID { get; set; }
        public int? CategoryID { get; set; }

        public decimal Price { get; set; }
        public int AmountOfStock { get; set; }
        public string ProductImage { get; set; }
        public string Details { get; set; }
        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        //Nav. Prop.
        public Brand? Brand { get; set; }
        public Category? Category { get; set; }

        public ICollection<ShoppingCart>? ShoppingCart { get; set; }
        public ICollection<AppUser>? Users { get; set; }
        public ICollection<InvoiceDetail>? InvoiceDetails { get; set; }
    }



    public class ShoppingCart:IBaseEntity
    {
        public int ShoppingCartID { get; set; }

        public int ProductID { get; set; }
        public int Amount { get; set; }

        public int AppUserID { get; set; }

        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        public Product? Product { get; set; }
        public AppUser? AppUser { get; set; }
    }




6. Hardware.Domain altında Enums klasörü açtık. 
String değerlerle numerik değerleri eşleştirmek için kullandık.
Bu projede silmeyeceğiz, silindi statüsüne alacağız kayıtları.
DİKKAT!!! bu projede log arşivlemesi yapmayacağız. Daha sonra eklenebilir.

public enum Status
    {
        Active=1,
        Modified=2,
        Passive=3
    }




