
Controller içerisindeki Token nedir?
[ValidateAntiForgeryToken]
web uygulamalarında sizin formunu dışında başka ortamlardan veri gelmesi sağlanabiliyor.
Bu onu bozuyor.
Arkada bir token oluşturuyor ve bunu ön yüze gönderiyor.
Daha sonra serverla bu token aynı olduğu için, yani başka bir yerden geldiğinde bu token bilgisi olmayacağı için işlemin yapılmasını engeller.
Bu konu ayrıca anlatılacak daha sonra web servisleri anlatırken. 
JWT Json Web Token teknolojisi. Servislerin güvenliği konusunda çok kullanılıyor. Zamana bağlı mesela 10 dk da bir tokeni değiştir diyebiliyor. Adam onu buluncaya kadar token değişiyor zaten.
jwt.io kendi resmi sitesinden baktık. Bunun ilginç bir kullanımı var. Üç parçadan oluşuyor. Sitede renklendirilmiş.
Token 50 yıllık teknoloji. WCF i anlatırken de token teknolojisini kullanıyorduk. 
Token bir madalyonun iki parçası gibi.
Client geldiğinde tokenlar aynıysa bu iki kişi birbirini tanıyor.
Sunucu oluşturuyor. Bir kopyası bende bir kopyası clientta.
Tokenlar hashlenmiş tutuluyor. 

Sessiondaki 20 dk hareketsiz kalırsa atma olayı farklı. 
Core da session kullanımı çok farklı. Düz mantıkla kullanamıyorsunuz.
Core öncesi sessionları istediğiniz gibi kullanabiliyordunuz. Core ile birlikte ilgili ayarları yapmadan  session ları kullanamıyorsunuz.
Session kullanıcı adı ve şifre ile sisteme giriş yaptınız diyelim. Giriş yaptıktan sonra sistem arka planda bir session oluşturuyor. 
Bu sessionları (herhangi bir ayarlama yapılmazsa standart ayarı 20 dk.) mekanizma siz pc den uzaklaştıktan sonra klavye ve fare eventleri kesildikten sonra 
session öldürülür ve login ekranına atıyor.
(core önce 1 dk nın altına düşemiyordunuz) (core da sn veya msn cinsinden session oluşturulabiliyor.)
Mantık token gibi. İki tarafta da session id bilgisi oluşturuluyor. İkisi aynı değilse bir taraf düştüğü için null olduğu için oturum kapatılıyor.

Hoca 1 lira bırakıp gitmenin dışında o sayfaya tıklanıp tıklanmadığının kontrol ediyormu araştıracak.

MS Identity konusunda profesyonel çözüm çıkarmış. Sıfırdan yazılabilir ama riskleri var. 

-------------------------------------------
MODELLER REVİZE SONRASI SON DURUM;

VİEWMODELS KLASÖRÜ İÇİNDE;
public class AuthorVM
    {
        public Author Author { get; set; }
        public AuthorDetail? AuthorDetail { get; set; }
    }

public class AppUser:IdentityUser
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public string Address { get; set; }
    }

public class Author
    {
        public int AuthorID { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }

        [NotMapped]
        public string FullName { get => FirstName + " " + LastName; }

        public AuthorDetail? AuthorDetail { get; set; }
        public ICollection<BookAuthor>? AuthorBooks { get; set; }
    }

public class AuthorDetail
    {
        [ForeignKey("Author")]
        public int AuthorDetailID { get; set; }

        [DisplayFormat(DataFormatString ="{0:d}")]
        public DateTime?  BirthDate { get; set; }
        public string? Region { get; set; }
        public string? Biography { get; set; }


        public Author? Author { get; set; }
    }

public class Book
    {
        public int BookID { get; set; }
        public string BookName { get; set; }
        public DateTime? ReleaseDate { get; set; }
        public string CoverImagePath { get; set; }
        
        [NotMapped]
        public IFormFile CoverImage { get; set;}
        public decimal Price { get; set; }

        public int CategoryID { get; set; }


        public Category? Category { get; set; }
        public ICollection<BookAuthor>? BookAuthors  { get; set; }
    }

public class BookAuthor
    {
        [Key]
        public int BAID { get; set; }
        public int BookID { get; set; }
        public int AuthorID { get; set; }

        public Book? Book { get; set; }
        public Author? Author { get; set; }
    }

public class Category
    {
        public int CategoryID { get; set; }
        public string CategoryName { get; set; }

        public ICollection<Book>? Books { get; set; }
    }


-------------------------------------------


1. Area - AdminPanel - Panel 

Index.cshtml bir önceki gündeki eski. Aşağıdaki sekilde revize.

<h1>Admin Panel Sayfasi....</h1>

<ul>
    <li><a asp-area="AdminPanel" asp-controller="Categories" asp-action="Index">Kategoriler</a></li>
    <li><a asp-area="AdminPanel" asp-controller="Authors" asp-action="Index">Yazarlar</a></li>
    <li><a asp-area="AdminPanel" asp-controller="Books" asp-action="Index">Kitaplar</a></li>
</ul>

PK FK ilişkisi gereği eğer kitap tablosuyla yazar tablosunu ilişkilendireceksem önce yazar tablosunu halletmeliyiz.

------

2. Author ve AuthorDetail tabloları birleştirilerek tek ekranda veri girilişi


2.a İki tabloyu view e taşımak için; Models klasörü altında ViewModels klasörü açarak onun altına AuthorVM classı ekliyoruz.

 public class AuthorVM
    {
        public Author Author { get; set; }
        public AuthorDetail? AuthorDetail { get; set; }
    }


2.b AuthorsController ı oluşturduk.

    [Area("AdminPanel")]
    public class AuthorsController : Controller
    {
        private readonly ApplicationDbContext _context;

        public AuthorsController(ApplicationDbContext context)
        {
            _context = context;
        }

        public IActionResult Index()
        {

            return View(_context.Authors.Include("AuthorDetail").ToList());
        }

        public IActionResult Create()
        {
            return View();
        }


        //UNIT OF WORK OLMADAN İKİ DEFA SAVE İLE. DİKKAT MAHSURU VAR.
        //[HttpPost]
        //public IActionResult Create(AuthorVM authorVM)
        //{    
            //if (ModelState.IsValid)
            //{              
               //İki SaveChanges() ile; FAKAT BURADA ŞÖYLE BİR SIKINTI VAR; MESELA O ANDA BENİM YAZARID 7 OLDU AMA O YAZARDETAYID Yİ BENDEN ÖNCE BAŞKASI ALMIŞ OLABİLİR.
               //_context.Authors.Add(authorVM.Author);
               //_context.SaveChanges();        //EF ekleme, düzenleme ve silme olarak kendisi SQL cümlelerini oluşturuyor arkaplanda. O yüzden tek SaveChanges() hallediyor.

               //if (authorVM.AuthorDetail != null)
               //{
                  //authorVM.AuthorDetail.AuthorDetailID = authorVM.Author.AuthorID;
                  //_context.AuthorDetails.Add(authorVM.AuthorDetail);
                  //_context.SaveChanges(); 
                  //return RedirectToAction("Index");
               //}
            //}
            //return View();
        //}


        //Unit Of Work Pattern UoW  - DAHA SADE - 
        BURADAKİ DEVRİM; KONSOLA BAKTIK.
        INSERT INTO AUTHORS (FIRSTNAME, LASTNAME) VALUES (@P0, @P1);
        SELECT AUTHORID FROM AUTHORS WHERE @@ ROWCOUNT = 1 AND AUTHORID = SCOPE_IDENTITY();       //DİKKAT!!! SCOPE_IDENTITY()
        INSERT INTO AUTHORDETAILS (AUTHORDETAILID, BIOGRAPHY, BIRTHDATE, REGION) VALUES (@P2, @P3, @P4, @P5);
        

        //SCOPE IDENTITY NEDİR?     https://ahmetrende.com/2010/11/23/sql-serverda-son-kaydin-id-degerini-almak-scope_identity/
        Genellikle uygulamalarımızda veritabanı ile bağlantı kurarız. Veriler çeker ya da yeni kayıtlar gireriz.
        Bazen bir tabloya eklediğimiz kaydın ID değerine o an ihtiyaç duyabiliriz.
        
        Bunu türlü yollarla yapabiliriz tabikide. Mesela kayıt işleminden sonra bir select sorgusu yazıp ID Kolonuna göre ters sıralayıp en üstteki satırın ID bilgisini çekebiliriz.
        Ne kadar da zahmetli 🙂
        Bu hem uzun ve yorucu hem de 2 farklı transaction çalıştıran bir işlem.
        
        Bunun yerine SCOPE_IDENTITY() kullanımına bakalım.
        
        
        Yandaki gibi “Urunler” tablomuz olsun. “UrunID” identity bir kolon. “UrunAdi” ise nvarchar tipinde bir kolon.
        
        Şimdi “USB Bellek” adında farklı bir kayıt ekleyelim. Sorgumuz eklenen kaydın ID değerini geri döndürecek. Bizim tablomuza göre “4” değerini vermeli.
        
        1
        2
        insert into Urunler Values ('USB Bellek')
        SELECT SCOPE_IDENTITY()
        
        Sorgumuzu çalıştırdığımızda şöyle bir çıktı alıyor olmamız gerek;
        
        Tabi ben sadece management üzerinde çalıştırdım bu sorguyu. Uygulama sırasında direk bu değeri çekebilirsiniz.
        Ya da sorgunuzda birden fazla tabloya bu ID ile kayıt girmeniz gerekiyorsa, sorgu içerisinde bir değişkene bu değer atanabilir. Şöyleki;
        1
        2
        3
        insert into Urunler Values ('USB Bellek2')
        declare @id int
        set @id =  SCOPE_IDENTITY()
        Artık “@id” değişkenini istediğiniz tabloya kayıt olarak girebilirsiniz.
        Son olarak;
        LinQ ya da entity framework gibi data modellerinde kullanmak için yazacağınız store procedure sonuna yani insert sorgusundan sonra “select” yerine “return” yazın.
        Böylece data modelindeki metot direk olarak int değerinde ki id değerini döndürecektir. 
        1
        return SCOPE_IDENTITY()



        //Tek SaveChanges() metodu ile PK ve FK kullanımı...
        [HttpPost]
        public IActionResult Create(AuthorVM authorVM)
        {
            byte state = 0;
                 
            if (ModelState.IsValid)
            {              
                _context.Authors.Add(authorVM.Author);

                state = 1;

                if (authorVM.AuthorDetail.BirthDate !=null || authorVM.AuthorDetail.Region != null || authorVM.AuthorDetail.Biography != null)
                {
                    authorVM.AuthorDetail.Author = authorVM.Author;        //NAVIGATION PROPERTY KULLANIM YERLERİNDEN BİRİ.
                    _context.AuthorDetails.Add(authorVM.AuthorDetail);

                   state = 2;               
                }
                _context.SaveChanges();    
            }

            if(state >1)
              return RedirectToAction("Index");
            else
              return View();
        }



        public IActionResult Test()            // DELEGE FATALITY İÇİN KULLANILAN METOD
        {
            //int count = FindCategories().Count(); 
            //
            //
            //int count = FindAuthors("a").Count();
            //

            //int count = Finds<Category>(x=>x.CategoryID %2==1).Count();
            string word = "a";
            int count = Finds<Author>(x=>x.FirstName.ToLower().Contains(word)).Count();

            List<Author> liste = Finds<Author>(x => x.FirstName.ToLower().Contains(word));

            string sonuc = "";
            foreach(Author a in liste)
            {
                sonuc += a.FirstName;
            }
            return Content("Sonuc=" + count.ToString()  + " " + sonuc);
        }



        DELEGE FATALITY

        //KategoriID si  tek olan  kategorileri getir?
        //Yazarın adında a harfi olanları getir?
        public List<Category> FindCategories()
        {

            //return _context.Categories.Find(id);
            return _context.Categories.Where(x=>x.CategoryID % 2==1).ToList();
        }

        public List<Author> FindAuthors(string word)
        {

            //return _context.Categories.Find(id);
            return _context.Authors.Where(x => x.FirstName.Contains(word)).ToList();
        }

        public List<TEntity> Finds<TEntity>(Func<TEntity,bool> where) where TEntity : class 
        {
            DbSet<TEntity> set = _context.Set<TEntity>();

            return _context.Set<TEntity>().Where(where).ToList();
        }
    }



2.c AuthorController ın Create.cshtml ini oluşturduk.

@using MVC_BookApp.Models.ViewModels;
@model AuthorVM

<form method="post" asp-area="AdminPanel" asp-controller="Authors" asp-action="Create">
    <table class="table table-striped">
        <tr>
            <td><label asp-for="Author.FirstName"></label></td>
            <td><input type="text" asp-for="Author.FirstName" class="form-control" required></input></td>
        </tr>
        <tr>
            <td><label asp-for="Author.LastName"></label></td>
            <td><input type="text" asp-for="Author.LastName" class="form-control" required></input></td>
        </tr>
        <tr>
            <td><label asp-for="AuthorDetail.BirthDate"></label></td>
            <td><input type="date" asp-for="AuthorDetail.BirthDate" class="form-control"></input></td>
        </tr>
         <tr>
            <td><label asp-for="AuthorDetail.Region"></label></td>
            <td><input type="text" asp-for="AuthorDetail.Region" class="form-control"></input></td>
        </tr>
        <tr>
            <td><label asp-for="AuthorDetail.Biography"></label></td>
            <td><textarea asp-for="AuthorDetail.Biography" class="form-control" cols="60" rows="5"></textarea></td>
        </tr>
        <tr>
            <td colspan="2"><input type="submit" value="Save Author Data" class="btn btn-primary"/></td>
            
        </tr>
    </table>
    <div asp-validation-summary="All"></div>
</form>



2.d AuthorController ın Index.cshtml ini oluşturduk.

@model IEnumerable<Author>

<table class="table table-striped">
    @foreach(var author in Model)
    {
    <tr>
        <td>@author.FirstName</td>
        <td>@author.LastName</td>
        @*<td>@author.AuthorDetail.BirthDate.Value.ToShortDateString()</td>*@

        <td>
            @if(author.AuthorDetail !=null)                    //DİKKAT!!! LEFT JOIN YAPILDI AMA BİZ NULL KONTROLÜ KOYMADIĞIMIZDAN GÖREMEMİŞTİK. 
            {
            @author.AuthorDetail.BirthDate.Value.ToString("dd/MM/yyyy")        // küçük mm yazılması MM ile aynı değil
            }
        </td>
       
    </tr>
    }
</table>



2.e 

