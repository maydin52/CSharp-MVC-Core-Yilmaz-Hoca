
MVVM(Model View ViewModel)  //DESKTOP TİPİ UYGULAMALAR İÇİN KULLANILIR. WEB İÇİN UYGUN DEĞİL.

Webforms tan MS desteğini 2019 da kaldırdı. Yerine Razor Pages geldi. 2001-2002 yılında başlamıştı. Şuan piyasada çok var da yavaş yavaş core a geçecekler. Düz MVC. 
*.aspx dosyaları => web forms uygulamalarıdır...
Backend front end olarak geçmiyor. Tek sayfada yazılıyor. Webform örneği yapmıştık.
NVC olmadığı için herşey tek sayfada. Bind<%
Düz MVC wizardı iyiydi. Minimum kodla yazılıyordu.
Uzun vadede maintenance zor ve yaşam çalışıyordu. 

Bir Web Uygulaması iki şekilde geliştirilebilir..
MVC(Model View Controller)
Razor Pages (DİKKAT MVC PATERNİ YOK AMA YÖNETMESİ MVC DEN DAHA ZOR.)

---------------------

Katmana neden ihtiyaç var?
Bir uygulama isteniyor fakat sonra patron geldi biz bu projeyi başka bir firmaya daha satacağız, fakat bu adamlar oracle da çalışıyor dedi.
Ne yapacağız? Katman yok. Uygulamanın heryerine yayılış vaziyette.

Ya da bu projeyi sattık, adamlar ağ kullanmadan kullanmak isteyirlar, windows projesi olarak hemde. 
Ne yapacağız? Katman yok. HTML CSS JS controllerlar, aksiyonlar ne olacak?
Veya önceden düz MVC yazmış, core a geçecek. Katmanlı yaptıysa DAL değişecek sadece.

Katman sayısı arttıkça bürokrasi artıyor.
Bürokrasi arttıkça sistem yavaşlıyor.

Adamın ihtiyacını doğru tespit etmek çok öenmli.
İhtiyacı olmayana fazlasını vermemek gerek.
Başlangıçta gidişatı iyi kestirmek, tedbiri ona göre almak gerekiyor. 
Katmanlıda işçilik maliyet artıyor ama uzun vadede kazanım oluyor. Yarın adam biz oracle a geçiyoruz dediğinde projeyi elden geçirmemek için.
Adamla baştan herşeyi konuşmak ve avukat aracılığyla ve hukuksal kriterlere dikkat ederek sözleşme yapmak lazım.

Katmanlı Mimari (n-Layer, n-Tier)  //Genellikle aynı gibi kullanılıyor ama katmanlar aynı bilgisayardaysa Layer, herbiri farklı bilgisayardaysa Tier olarak geçer.
Tarihçesi network tarihçesiyle aynı. 1960 lara dayanıyor.
Servislerde bir katmandır.

Genelde kullanılan katmanlar;
DAL (Data Access Layer)      //sadece veriyi alıp bana göndermek ya da benden veri alıp db ye eklemek yani al - ver.
BLL (Business Logic Layer)     //yapılan işlerle ilgili raporlar, hesaplamalar, iş mantıkları
PL  (Presentation Layer)    //Ortam bağımsızlığı konusu.

Hocanın çizdiği şema şöyle;

DAL <-> BLL <-> PL <---> DB

  DAL-BLL-PL BAĞLI
     M O D E L   veya   E N T I T Y


Katmanlar birbirlerini geçip ilerleyemez. Birbirleri üzerinden iletişim kurarlar. OSI layerda da öyle.
Onion daha esnek, böyle değil. Kümülatif olarak toplaya toplaya içine ala ala gider. Soğanın içindeki katmanlar gibi. Cücük Core yani Domain.
Bu normal katmanlı mimarideki sorunları da çözüyor.
Küçük projelerde katmanlıya gerek olmayabilir. Bazen bazı katmanlardan direkt geçmek isteyebiliyoruz.

Örneğin; web de OSI LAYER 

Katmanli Mimari; Bir projeyi daha iyi yönetebilmek için mantıksal ve fiziksel olarak 
         birbirinden ayırmak veya parçalara ayırmak için kullanılır...

Mesela yeni bir model tanımlanacak, adam nereye bakacağını biliyor.
Mesela adam dedi yeni bir rapor ekleyeceğim. Yazacağım yer belli. Ön yüze yazmıyorum.

*** N.S.A. Her katman birbirinden bagimsiz olmalı... Katmanlar arası bağımlılık olmamalı.

Bir standarda göre yazılması gerekiyor.

Katmanlar DLL dosyalarıyla ayrılırlar. Fakat birbirleriyle bağlantıları var. Ama bir taraftanda birbirinden bağımsız. SQL çıkarıp Oracle taktığında çalışmasına devam etmeli.
Eğer etmiyorsa bu katmanlı mimari değildir.

Repository katmanı DAL ve BLL arasında olur. Onion da Infrastructure da.
Repository depo demek. 
Bazen sql de bazen oracle da ya da mysql dede tutabiliyor. Örneğin arge de farklı, satışta farklı db gibi. Önceden başlamıştır çalışıyordur dokunmamışlardır gibi.
Neden önemli? Bazen öyle bazen böyleyse Kimin neyi çalıştıracağına Repository üzerinden karar veriliyor. Yani bazen SQL DAL bazen Oracle DAL çalışıyor gibi.

API de PL ile BLL arasında bir yerde.
API MVC altyapısını kullanır ama View yoktur. Yani kullanıcıya View gitmez, data gider. Buradaki View string ama JSON veya XML veya CSV data olarak gidiyor ama istek geldiğinde 
yine DAL dan geçmesi gerekir. İstek PL üzerinden gelmeyecekse, dış dünyadan bir yerden geliyorsa BLL ve DAL dan veriyi getirip JSON döndüm yani PL kullanılmadı. Adam ö yüzde
istediği gibi kullansın. Bu mantık genelde B to B uygulamalarında ya da SPA Single Page Application da kullanılır. SPA de ön yüzde sadece bir sayfa vardır. Tek sayfadan oluştur.
Adam önyüzde ekranını sadece HTML CSS JS REACT ANGULAR VUEJS vs kullanarak oluşturuyor ve servis üzerinden veriyi çekiyor. 
Özellikle trendyol vs sitelerde dükkan açıyorsunuz. Kendiniz ürün ekliyorsunuz. Adamın veritabanına insert yapabilmek için connection string bilmem ve bana erişim olması lazım. 
Ama milyon adama bu veritabanı açılmaz. İşte servis mantığı burada devreye giriyor. Yine trendyol veritabanına ekliyor ama doğrudan değil, servis aracılığıyla.
Servis içindeki CRUD metodları da birbirinden farklı olabilir servis mantığı olmazsa. Adama ben sadece ekle metodunu açıyorum ve trendyola bu metod üzerinden gidiyor.
Eskiden metadata açılıyormuş. Servisin içindeki metodları görmesi gerekiyordu. Adam nereden bilecek. Birisi ekle der, birisi ürün ekle der, bilemez.
WCF servislerde meta datalar ne olduğunu, parametrelerini söyler. İmplement formatındadır, ekranda gösterir. 
Şimdi Restfulservislerde ona gerek kalmadı. Sadece servisin adresini bilmek yeterli. Çünkü 4 eylem var; put, post, delete, get. 
Siz sadece yapacağınız eylemi bunlar üzerinden gönderiyorsunuz, arkadaki metodun ismini bilmek zorunda değilsiniz.
Ekleme yapacaksan post, update yapacaksam put olarak göndermem yeterli. Kendisi arka planda bunu çözüyor. 
jwt.io günümüz servislerinin büyük ısmı güvenlik için bunu kullanıyor. Detayı önceki deslerde var.

------------------------

Örneğin katmanları yazmak için iş bölümü yapacağız;
1. Önceden modelin ve ilişkilerin kararlaştırılmış olması gerekiyor.
2. Mesela DAL yazılmadan BLL veya servisi yazacak adam birşey yapamaz. Belirli bir seviyeye kadar gelmesi gerekiyor. 
3. O seviyeye kadar ortak gidilir daha sonra görev planlamaları ayrılır.


İşi uzatıyor ama uzun vade yatırımı katmanlı mimari

------------------------

Doğrudan bir katmana ulaşamadığımız için; 
Normal katmanlıda her dll kendisinden bir öncesine ve bir sonrasına referans veriyor. Oysa Onion da kümülatif.
Kodlama maliyetlerini düşürüyor ve bazı problemleri daha azaltıyor.
Eskiden daha karmaşık yazdığımız uygulamaları daha az yazıyoruz. 

Bazen PL direkt DAL dan okumak istiyor. Böyle olunca boşu boşuna BLL de işyükü oluşuyor. 
İkisinde de katman sayısı arttıkça performans düşer ama biz bunu göze alıyoruz çünkü konu uzun vadede avantaj.
Aslında düz katmanlı yönteme en iyi uyan yöntem bağlantılı yöntemdir yani EF olmadan. O zaman cillop gibi.
DAL yazarken Ef bu katmana eklemek zorundayım. DAha sonra PL katmanında da DbContext sınıfını tanıması için EF yi Pl e ekleme zorunda kalıyoruz. 
Yani iki ayrı katmana EF ekledim. Oniondan önce katmanlı mimaride EF kullanılıyorsa katmanlı mimarin,n ruhuna aykırı işler yapılıyor. 
Yani her katman bağımsız olacaktı ama burada her iki katman da EF ye bağımlı. Oysa Onion da bu tip problemler çözülmüş. Core a Ef eklenirse kümülatif gittiğinden problem çözülmüş.

Onion Modelde ise ; tum katmanlar birbirine eklenenerek buyur... 2008 DE GELMİŞTİR. DİĞERİNE ZİYADE BU DAHA YÖNETİLEBİLİR.
Core(Domain) - yuvarlağın en merkezinde     // ENTITY
Infrastructure - bir sonraki çember içinde      // VERİYE ERİŞİM
Application - bir sonraki çember içinde    // O VERİYİ NASIL KODLAYACAKSINIZ BURADA KODLAMA YAPISI KARAR YAPILARI VS.
Presentation veya UI(User interface) - bir sonraki çember içinde - bu çember alanı da ayrı parçalara ayrılabiliyor. Bir kısmı MVC bir kısmı Windows gibi. // AL - VER GÜLÜM.
                                                                    //KULLANICIDAN VERİYİ ALACAK VE GÖNDERECEK SADECE. HERHANGİ BİR MANTIK YOK. MANTIK BİR ÖNCEKİNDE.

Domain / Core
Infrastructure / DAL
Application / BLL
UI / Presentation


Dikkat!!! Normal katmanlıda bir öncekiyle ve bir sonrakiyle ilişki kuruluyor. Ayarlarken dikkat!!!

----------------------------------------------------------------------------------------------------------------------------------------------------

DLL OLUŞTURMA

1. Yeni Class Library açıyoruz. (Arama seçeneklerinden c# All platforms ve Library seç - ilk seçenek)

2. İlk çalışma için Matematik ismini verdik.
Dikkat!!! DLL dosyası direkt çalışmaz. Çünkü main yoktur. Exe dosyaya ihtiyaç var. O yüzden katmanları yazarken dikkatli gitmek gerek.

3. Matematik dosyası içinde class açtık.

public class Cebir
    {
        public int KareAl(int sayi)
        {
            return sayi * sayi;
        }
        public int Topla(int sayi1, int sayi2) 
        { 
            return sayi1 + sayi2;
        }

        public int KupAl(int sayi)
        {
            return sayi * sayi * sayi;
        }
    }

4. Yazdıktan sonra rebuild ediyoruz.

5. Open Folder in File Explorer - bin - debug - net6.0 içinde Matematik.dll dosyasının oluştuğunu göreceksin.

-------------

DLL DOSYAYI KONSOL UYGULAMASINDA KULLANMA
//Cebir DLL dosyasında daha sonra değişiklik yaptığında yansıyor.
//Hem de exe dosyanın olduğu yere de getiriyor.

1. Yeni Consol App açıyoruz.

2. proje üzerinde sağ tık - Add - Project Reference - Matematik seçeneğini klikle (içinde açık değilse browse ile dosya yolundan seç) - OK

3. Program.cs de aşağıdaki gibi çalıştırıyoruz.

using Matematik;

Cebir cebir = new Cebir();
Console.WriteLine(cebir.KareAl(4));
Console.WriteLine(cebir.Topla(4,5));
Console.WriteLine(cebir.KupAl(4));

---------------

DLL DOSYAYI WINDOWS UYGULAMASINDA KULLANMA
//Form1 açıkken sol üstte Form1 başlığı solundaki monitör logosu mavi ise .NET, siyah ise Core da açık demektir.

1. Yeni Windows Form App açıyoruz.

2. proje üzerinde sağ tık - Add - Project Reference - Matematik seçeneğini klikle (içinde açık değilse browse ile dosya yolundan seç) - OK

3. Form classı içerisinde aşağıdaki gibi çalıştırıyoruz.

        private void button1_Click(object sender, EventArgs e)
        {
            Cebir cebir = new Cebir();

            MessageBox.Show(cebir.KupAl(5).ToString());
        }

---------------
İLK PROJE DOSYASINI OLUŞTURMA

1. Visual Studio başlangıç ekranından Blak Solution seçiyoruz.
Solution Name : Hardware
Create

2. proje üzerinde sağ tık - add new item - txt dosyası oluşturulur. 

Projede Yapılacaklar;
*** Konu:Bilgisayar Parcalari
*** UI:MVC Core 6
*** Entity FrameworkCore
*** IEntityTypeConfiguration kullanımı...(FluentAPI)
*** Onion Katmanlı Modeli kullanılacak
*** Dll olusturma (Katmanlar icin)
*** Generic Repository kullanılacak...
*** Interface kullanılacak
*** Identity ile Uyelik sistemi(Admin,Rol)
*** AutoMapper kullanımı
*** Sepet ve Stok kullanımı...
*** 4-veya 5 tablo olacak
*** Identity kullanımında Idler int olmali...
*** Veritabindan silme islemi olmayacak...(Aktif/Pasif)
*** DTO(I,U), ViewModel(SELECT) 
    - ViewModel ; genelde select için kullanılır. Daha önce resim eklemek için kullandığımız IFormFile interface ini Application katmanında Viewmodelde kullanacağız. Çünkü önyüzle alakalı. Web projesinde böyle. Win form uygulamasında
ön yüz olayı olmadığından bu interface e gerek yok. 
    - DTO ; genellikle insert ve update için kullanılır. Örneğin insert yaparken id göndermemize gerek yok. 

Analiz: Hardware Project
 Product(ProductID, BrandID,CategoryID, Name, Price,Stock,ProductImage, Detail )
 Category(CategoryID, Name)
 Brand(BrandID, Name) 
 Model(ModelID, BrandID,CategoryID, ModelName) 
 ShoppingCart(ID, ProductID, Amount,UserID)
 Invoice(ID,UserID,Date, )
 InvoiceDetail(ID, InvoiceID, ProductID, Amount,Price )

 + IdentityTables


21/10/2023
 *** Entities, Enums
 *** Nav.Props. 
 *** Infrasutructure Layer
 *** Domain Katmanını referans olarak ver...
 *** EFCore yukle...
 *** DAL(Context => IdentityDbContext)  //Sıfırdan yazılan bir Identity sisteminde hata çıkma ihtimali çok yüksek.
 *** DbSet tanımlamalari...
 **** override OnModelCreating() , OnModelConfiguring()
 *** FluentAPI => IEntityTypeConfiguration
 *** Initial values...
 *** Migration
 *** Update-Database
 TODO
 ***Repository .....


22/10/2023
 *** 

 28/10/2023
 *** userRoles tablosunda admin yok 1 1 !!!!

 ***AppUser 
 *** Login,LogOut, Register
 *** Automapper kullanımı gosterilecek...

 *** UI Katmanını olustur...
 *** Application katmanını refarans olarak ver...
 *** DbContext sınıfını ve Identity ayarlarını yap...
 *** appsettings.json dosyasına connection string'i yaz...


Automapper kullanımı
 *** Nuget uerinden gerekli paketi yukle...
     Automapper.Extensions.Microsoft.DependencyInjection
 
 *** Application katmanında
     Bir klasor olustur içerisine bir sınıf olustur...
     Profile sınıfından bu sınıfı türet...
     ctor => içerisinde Map tanılamalarını yapınız...

 *** program.cs tarafında (IoC Container için)
   
     buider.Services.AddAutoMapper(x=>x.AddProfile(new Mapper()))

 !!! Login oldugunda Rol bilgisi gelmiyor....







Dikkat!!! sıfır veri giremesin ve stokta kaç tane varsa ayı gelsin pratik çözümü;
HTML number taginin min max değerleri var. - kontrolünü de bu şekilde yapabilirsin stok değerini de db den çekersin.








3. Proje üzerinde sağ tık - add - new project - class library - isimlendirmeye dikkat Hardware.Domain (Hardware.Core diyen de var) - Next - Create
Hardware.Domain altında Entities (veya Models de olur) adında yeni klasör açtık.
Class1 i sildik.




4. Nugetten Microsoft.AspNetCore.Identity.EntityFrameworkCore seçip, domain projesini seçip, versiyon seçip 6.0.23 yüklüyoruz.
AppUser:IdentityUser<int> vr AppUser:IdentityUser<int> için. Dikkat!!! önceden UserId varchar(250) idi, guid tutuyordu. Int çevireceğiz.
IdentityUser den türetmemiz gerektiği için bunu yaptık.
Bunu normal katmanlı mimaride yaptığınızda herşey birbirine giriyor. Katmanlar birbirinden bağımsız olmalıydı ama ben DAL ı EF ye bağlıyorum.
Onion da toplaya toplaya gittiği için oradan kurtarıyor.
Normal katmanlıda bu sefer her iki katmana da framework kurulması gerekiyor bu da bağımlılık oluşturuyor.



5. Entities klasörü içerisinde iki klasör daha oluşturduk; birisi Abstract diğeri Concrete.

5.a Abstract klasörü içerisine aşağıdaki interface ekledik;
Neden interface? Çünkü interface soyut bir yapıdır. Ramde karşılığı olmaz.
Id neden vermedik? EntityID tercih ediyoruz. AppUser ve AppRole tablolarından da ID gelecek. Sorun olacağı için eklemedik. Identity özelleştirmesi olmasaydı eklenebilirdi.
Loglama her tablo için olmasa da çok stratejik konularda ayrı tablolarda kaydedilir. Her tablo için olması; kapladığı alandan ziyade sunucu ile sürekli konuşması olumsuz performans.


public interface IBaseEntity
    {
        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }      //nullable
        public DateTime? PassiveDate { get; set; }    //nullable
        public Status Status { get; set; }
    }




5.b Concrete klasörü içerisine aşağıdaki interface ekledik;
- Neden Concrete? Çünkü Ramde karşılıkları olacak. Gerçekte olması gereken sınıfları yerleştiriyoruz.

UML toollarını aaraştır.
Online olanları da var. 
https://www.google.com/search?q=online+database+design+tool&rlz=1C5CHFA_enTR1036TR1036&oq=online+database+design+tool&aqs=chrome..69i57j0i512j0i22i30l8.6209j0j7&sourceid=chrome&ie=UTF-8
https://dbdiagram.io/home
bkz. foto



    //IdentityRole go to definition ile varsayılan alanları incele.
    //İlişkiyi kendisi kurduğu için EF halledecek.


    //Rol için veritabanında oluşan çokaçok tabloyu burada model oluşturmadık.


    public class AppRole : IdentityRole<int>, IBaseEntity
    {
        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        public ICollection<AppUser>? Users { get; set; }
    }



    //IdentityUser go to definition ile varsayılan alanları incele.

    public class AppUser:IdentityUser<int>,IBaseEntity        //MS in tablosuna ilave ekstra istenilen alanlar
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public string Address { get; set; }


        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        public ICollection<Product>? Products { get; set; }
        public ICollection<Invoice>? Invoices { get; set; }

        public ICollection<AppRole>? Roles { get; set; }

    }



    public class Brand:IBaseEntity
    {
        public int BrandID { get; set; }
        public string Name { get; set; }


        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        public ICollection<Model>? Models { get; set; }
        public ICollection<Product>? Products { get; set; }
    }



    public class Category:IBaseEntity
    {
        public int CategoryID { get; set; }
        public string Name { get; set; }


        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        public ICollection<Model>? Models { get; set; }
        public ICollection<Product>? Products { get; set; }
    }



    public class Invoice:IBaseEntity
    {
        public int InvoiceID { get; set; }
        public DateTime InvoiceDate { get; set; }

        public int AppUserID { get; set; }

        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        public AppUser? AppUser { get; set; }
        public ICollection<InvoiceDetail>? InvoiceDetails { get; set; }
    }



    public class InvoiceDetail:IBaseEntity
    {
        //ID, InvoiceID, ProductID, Amount,Price

        public int InvoiceDetailID { get; set; }
        public int InvoiceID { get; set; }
        public int ProductID { get; set; }
        public int Amount { get; set; }
        public decimal Price { get; set; }

        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        public Invoice? Invoice { get; set; }
        public Product? Product { get; set; }

    }



    public class Model:IBaseEntity
    {
        public int ModelID { get; set; }
        public string Name { get; set; }

        public int? BrandID { get; set; }
        public int? CategoryID { get; set; }

        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        public Brand? Brand { get; set; }
        public Category? Category { get; set; }

    }



    public class Product:IBaseEntity
    {
        public int ProductID { get; set; }
        public string Name { get; set; }

        public int? BrandID { get; set; }
        public int? CategoryID { get; set; }

        public decimal Price { get; set; }
        public int AmountOfStock { get; set; }
        public string ProductImage { get; set; }
        public string Details { get; set; }
        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        //Nav. Prop.
        public Brand? Brand { get; set; }
        public Category? Category { get; set; }

        public ICollection<ShoppingCart>? ShoppingCart { get; set; }
        public ICollection<AppUser>? Users { get; set; }
        public ICollection<InvoiceDetail>? InvoiceDetails { get; set; }
    }



    public class ShoppingCart:IBaseEntity
    {
        public int ShoppingCartID { get; set; }

        public int ProductID { get; set; }
        public int Amount { get; set; }

        public int AppUserID { get; set; }

        public DateTime CreateDate { get; set; }
        public DateTime? UpdateDate { get; set; }
        public DateTime? PassiveDate { get; set; }
        public Status Status { get; set; }

        public Product? Product { get; set; }
        public AppUser? AppUser { get; set; }
    }




6. Hardware.Domain altında Enums klasörü açtık. 
String değerlerle numerik değerleri eşleştirmek için kullandık.
Bu projede silmeyeceğiz, silindi statüsüne alacağız kayıtları.
DİKKAT!!! bu projede log arşivlemesi yapmayacağız. Daha sonra eklenebilir.

public enum Status
    {
        Active=1,
        Modified=2,
        Passive=3
    }


7. Hardware.Domain altında Repositories klasörü açtık.
Burada concrete sınıfı olmayacak. Sadece interface olacak. Bağlantı noktasını kurmak için kullanacağız. 
Repository aslında bir patern.
Mesela DAL katmanında MSSQL çalışıyor ama firma dedi ki bazı şartlarda Oracle a yazsın bazı şartlarda Oracle a yazsın.
DAL ve BLL arasına bu yüzden bu katman geliyor ve nereye kaydedileceğine karar veriyor. Diğer katmanlı da Repository ayrı bir katman.
Katmanın mantığı Oracle söküp MSSQL takabilmek.
Bkz foto.

Brand ve diğer tüm tablolara veri eklemek için  için xxxs.Add(xxx) ve SaveChanges()
CRUD işlemleri
Add, Remove, Update, List, Find hepsi için olmalı.
Normal şartlarda hepsine bunların yazılması gerekiyor.
EF desteklemese zaten yazamayız, destekliyor.
Repository oluşturunca her birine bunları yazmaya gerek kalmayacak.


Peki neden hem Domainde hem de Infrastructure da Repositories klasörü var?
Standart katmanlı mimari 


SQL sql = new SQL(); //SQL katmanı olduğunu varsayalım.
BLL bll = new BLL(); //Bu katmanda SQL katmanını çalıştırmak istersem ne yapmalıyım?
ctrounda SQL sql = new SQL(); // oracle istiyorsamda ORACLE oracle = new ORACLE();
Solid Prensipleri gereği (5 prensip) 2. prensip derki ; OCP yani Open Closed Principles; 
opened extension closed modification. Yani bir yapı gelişime açık olmalı fakat modifiye edilmemeli.
Yeni bir şeyin gelmesi modifiye değildir. 
Yani SQl silip ORACLE yazarsak bu prensibi ezmiş oluruz.
5. prensip Dependecy Inversion Principles derki; Bağımlılıkların tersine çevrilmesi ilkesi. 
Biz ctor veya metodun yapının içinde DbContext _context = new DbContext yazmıştık ama hoca asla böyle kullanmayacağız, doğru değil demişti.
Düz MVC de ya yazılıyor ya da injektorler kullanılıyormuş.
Bu otomatik newlemeyi IOC gönderiyor. 
SQLi değiştirip ORACLE ı yazmak bir bağımlılık oluşturur. yani gidip birini silip öbürünü yazmam gerekiyor. 
Bunun literatürdeki özel ismi Tight Coupling yani sıkı bağlı.
Aslında istenen Loose Coupling yani gevşek bağlamadır.
Interfaceleri yapıları bağımlılıktan kurtarmak esnek hale getirmek için kullanırdık.
- ICRUD interfacei oluştursam; 
- Tablolara ICURD interfaceini bağlasam 
- ctor(ICRUD db)
{
  
}
yani bağımlılığı dışarı çıkardık. Yani classı kim oluşturuyorsa o gönderiyor. Ne gönderirse o çalışır.
AddRange metodu ICollection konusu. Adam dizi array vs demiyor, koleysiyon olsun bana yeter diyor.

Bu yüzden domainde repositoryde sadece bağlantı noktalarını yazdık.
Diğer katmanla sözleşme yapmak gibi.
Fiş priz ilişkisi. Katmanların bağımsızlığı bu demek.
Her cihaz için ayrı priz olsaydı ne olurdu??
Benim nereye kaydedeceğim infrastructure da belli.
Infrastructure içindeki repository de de concrete halleri olacak.

Standardın dışındaki yapıyı eklemek için hepsi için açıyoruz.

DAL katmanında işin yapılmasıyla ilgili hiçbirşey bulunmaz. 
İşin nasıl yapılacağı BLL katmanında olmalıdır.
İşlerin herbiri birer servis. Application katmanına yazılıyor.
Mesela login ile ilgili ne varsa orada olacak.
Daha sonra bu şekilde ilerleyeceğiz.


ÖZÜ : 
Yani Domain katmanındaki interface repositoryler ile infrastructure katmanındaki concrete repositoryler arasında bağlantı noktası oluşturarak birbirine baağlıyoruz.
Loose Coupling haline getiirmek.

// sadece IBaseEntity i implemente etmiş olmalı. Kısıt koyduk.



ASENKRON PROGRAMLAMA:
- Önceden cpu lar tek çekirdekti. Düzensiz gelem işlerde ya sırayla ya da qeune ile ya da zamanı bölerek bunun algoritmaları var. Düşük sistemde hareketin kesik kesik olması
- Sonra çekirdek sayısı artınca eskiden kasada bir kişi olunca şimdi örneğin 4 kişi oldu. İşler daha hızlı ilerledi ama bu seferde herkes daha fazla gelmeye bağladı. Yani istek arttı.
Donanım artıyor ama örneğin polygon sayısı arttı.
çekirdeklerin çalıştırılması özelleştirilebiliyor.
intel boost : sokak kavgası 4x4. 4 kişi bir kişiye giriyor. Ramde kalan işlemleri sürekli kenara çektiğinden birşeyler birikmesin diye bir gir bitir mantığı.
asenkron ; Bir iş devam ederken başka bir işin daha başlaması. 

Sıkıntı şu : 
Single thread : sıralı, farklı sürelerde, önce a, sonra b, sonra c işlemi yapılması gerekiyor normalde. Toplamda 12 sn.
Bu işlemleri neden sırayla yapıyoruz? sorusundan yola çıkılarak;
İlk işe başladıktan kısa bir süre sonra aynı anda farklı kanallar açarak diğer işlere başlıyor. 
En uzun iş bittiğinde diğerleri de bitmiş oluyor. Yani en uzun işin diğerlerini beklemesi gerekiyor await bunun için kullanılıyor. 
Hem süreden, hem de dosya okuma ve yazma işlemlerinden ciddi zaman kazanımı sağlanıyor.

C# 5.0 2012 yılında bazı metotlar Beginx() ve Endx() gördüysen bu da asenkron kullanımına örnek. Callback delegesi vardı.
5.0 dan sonra yani 2010 lı yıllarda node.js ten sonra asenkron konusu dünyanın dikkatini çekince MS te geçti. 
Bütün asenkron dönüş tipleri Task ve metod sonlarında ASync geldi.


Bunları kütüphane için DLL e yazıp ihtiyaç halinde içeri alabilirsin.


public interface IBaseRepository<T> where T : IBaseEntity
    {
        //void Add(T entity); //Asenkron olmadan yazmak istesydik...
        Task AddAsync(T entity);
        Task<int> UpdateAsync(T entity);      // örneğin one row effected dönüşü için. Mesela 0 geliyorsa kayıt çalışmadı gibi yakalanması.
        Task DeleteAsync(T entity);
        Task<T> FindByIDAsync(int id);        //update için idden araması gerekiyor
        Task<T> FindByIDOnlyActiveAsync(int id);
        Task<IQueryable<T>> GetAllAsync();    //IQueryable sorgulanabilir demek. List dönerse nav prop ulaşamayız. EF desteklemiyor. Where, Select vs yazarken dikkat IQueryable. En son liste çeviriyorduk. List gelen sorgular Include ile joinlenemez. O zaman var result gibi uzun yazmak gerekir.
        Task<IQueryable<T>> GetOnlyAllActivesAsync();
    }


    public interface IAppRoleRepository : IBaseRepository<AppRole> 
    {
    }



    public interface IAppUserRepository :IBaseRepository<AppUser> 
    {

    }



    public  interface IBrandRepository : IBaseRepository<Brand> 
    {
    }



    public interface ICategoryRepository : IBaseRepository<Category>
    {
    }



    public interface IInvoiceDetailRepository : IBaseRepository<InvoiceDetail> 
    {
    }



    public interface IInvoiceRepository : IBaseRepository<Invoice> 
    {
    }



    public interface IModelRepository: IBaseRepository<Model> 
    {
    }



    public interface IProductRepository : IBaseRepository<Product> 
    {
    }



    public interface IShoppingCartRepository : IBaseRepository<ShoppingCart> 
    {
    }




8. Proje üzerinde sağ tık - add - new project - class library - isimlendirmeye dikkat Hardware.Infrastructure - Next - Create
Infrastructure : altyapı
Burada DAL yazacağız. 



9. Nugetten eklentileri yüklüyoruz.
- Microsoft.EntityFrameworkCore seçip, Infrastructure projesini seçip, versiyon seçip 6.0.23 yüklüyoruz.
- Microsoft.EntityFrameworkCore.SqlServer, Infrastructure projesini seçip, versiyon seçip 6.0.23 yüklüyoruz.
- Microsoft.EntityFrameworkCore.Tools, Infrastructure projesini seçip, versiyon seçip 6.0.23 yüklüyoruz. DİKKAT!!! Yükleme ekranında options altında komut listesi
- Infrastructure da ihtiyacımız olduğu için buraya yükledik. Herşeyi Core a atmıyoruz.



10. Katmanların birbirini görmesi için Hardware.Infrastructure üzerinde sağ tık - Add - Project Reference - Hardware.Domain tikleyip kaydediyoruz.
Üst katmandan alt katmana ilişki tanımlanıyor. Yön önemli. Mesela 2 katmandan 5. katman görünmez ama 5. katmandan 2. katman görünür.
Diğer katman mantığında hepsi kendisinden bir öncekine ve bir sonrakine bağlıydı yani birinci ve üçüncü katman ikinci katman üzerinden birbiriyle iletişim kuruyordu.

DİKKAT!!! Tepesolution üzerinde sağ tık - properties - current selection



11. Hardware.Infrastructure altında EntityConfigurations klasörü açtık.
İçine her modelin aşağıdaki configlerini oluşturduk.

    public class AppRoleCFG : IEntityTypeConfiguration<AppRole>
    {
        public void Configure(EntityTypeBuilder<AppRole> builder)
        {
            builder.HasData(
                new AppRole { Id = 1, Name = "Admin", NormalizedName = "ADMIN", ConcurrencyStamp = Guid.NewGuid().ToString() },
                new AppRole { Id = 2, Name = "User", NormalizedName = "USER", ConcurrencyStamp = Guid.NewGuid().ToString() });


        }
    }


    public class AppUserCFG : IEntityTypeConfiguration<AppUser>
    {
        public void Configure(EntityTypeBuilder<AppUser> builder)
        {
            //DİKKAT!!! NORMALIZEDUSERNAME VE NORMALIZEDEMAIL BOŞ BIRAKILMAYACAK VE BÜYÜK HARFLERLE DOLDURULACAK. LOGIN İŞLEMİNDE IDENTITY NİN BUNA BAKTIĞI ANLAŞILDI TESTTE.
            //IDENTITY VARSAYILAN DÜZENİNE UYSAYDIK KENDİSİ DOLDURUYORDU. BİZ MÜDAHALE ETTİĞİMİZ İÇİN BUNLARI DA DOLDURMAK ZORUNDAYIZ.
            // SecurityStamp de olmazsa yanlış çalışır.

            AppUser user = new AppUser
            {
                Id = 1,
                FirstName = "root",
                LastName = "user",
                UserName = "rootUser",
                NormalizedUserName = "ROOTUSER",
                Email = "rootuser@deneme.com",
                NormalizedEmail="ROOTUSER@DENEME.COM",
                Status = Domain.Enums.Status.Active,
                CreateDate = DateTime.Now,
                SecurityStamp = Guid.NewGuid().ToString(),
                Address="Everywhere"
                
            };

            PasswordHasher<AppUser> password = new PasswordHasher<AppUser>();
            user.PasswordHash= password.HashPassword(user, "rootUser_123");
            builder.HasData(user);
            
           
        }
    }


    public class BrandCFG : IEntityTypeConfiguration<Brand>
    {
        public void Configure(EntityTypeBuilder<Brand> builder)
        {
            builder.Property(x => x.Name)
                .HasColumnType("varchar")
                .HasMaxLength(30)
                .IsRequired(true);

            //Params kullanımı. Bir dizi ama dizi göndermiyoruz, virgüllerle gönderiyoruz.

            builder.HasData(
                new Brand { BrandID=1, Name="Intel", CreateDate=DateTime.Now, Status = Domain.Enums.Status.Active },
                new Brand { BrandID=2, Name="Amd", CreateDate=DateTime.Now, Status = Domain.Enums.Status.Active },
                new Brand { BrandID=3, Name="Hp", CreateDate=DateTime.Now, Status = Domain.Enums.Status.Active }
                );

            
        }
    }



    public class CategoryCFG : IEntityTypeConfiguration<Category>
    {
        public void Configure(EntityTypeBuilder<Category> builder)
        {
            
            builder.HasData(
                new Category { CategoryID=1, Name="CPU", CreateDate=DateTime.Now, Status=Domain.Enums.Status.Active },
                new Category { CategoryID=2, Name="Printer", CreateDate=DateTime.Now, Status=Domain.Enums.Status.Active },
                new Category { CategoryID=3, Name="GPU", CreateDate=DateTime.Now, Status=Domain.Enums.Status.Active },
                new Category { CategoryID=4, Name="Laptop", CreateDate=DateTime.Now, Status=Domain.Enums.Status.Active }
                );
        }
    }



    public class InvoiceCFG : IEntityTypeConfiguration<Invoice>
    {
        public void Configure(EntityTypeBuilder<Invoice> builder)
        {
            
        }
    }



    public class InvoiceDetailCFG : IEntityTypeConfiguration<InvoiceDetail>
    {
        public void Configure(EntityTypeBuilder<InvoiceDetail> builder)
        {
            
        }
    }



    public class ModelCFG : IEntityTypeConfiguration<Model>
    {
        public void Configure(EntityTypeBuilder<Model> builder)
        {
            
        }
    }


    public class ProductCFG : IEntityTypeConfiguration<Product>
    {
        public void Configure(EntityTypeBuilder<Product> builder)
        {
            
        }
    }



    public class ShoppingCartCFG : IEntityTypeConfiguration<ShoppingCart>
    {
        public void Configure(EntityTypeBuilder<ShoppingCart> builder)
        {
            
        }
    }




12. Hardware.Infrastructure altında HardwareDBContext oluşturduk.

public class HardwareDBContext:IdentityDbContext<AppUser,AppRole,int>    
    {
        public HardwareDBContext()        //Katmanlı mimaride bu boş constructorun tanımlanması gerekiyor. Yoksa migration yaptığımızda bunu dolduramadığı için hata alırız.
        {
            
        }
        public HardwareDBContext(DbContextOptions<HardwareDBContext> options):base(options)    //
        {
            
        }

        public DbSet<Product> Products  { get; set; }
        public DbSet<Brand> Brands  { get; set; }
        public DbSet<Category> Categories  { get; set; }
        public DbSet<Invoice> Invoices  { get; set; }
        public DbSet<InvoiceDetail> InvoiceDetails  { get; set; }
        public DbSet<Model> Models  { get; set; }
        public DbSet<ShoppingCart> ShoppingCarts  { get; set; }
        public DbSet<AppUser> AppUsers  { get; set; }
        public DbSet<AppRole> AppRoles  { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            base.OnConfiguring(optionsBuilder);
            optionsBuilder.UseSqlServer("Data Source=.;initial catalog=HardwareDB;integrated security=true");
        }

        protected override void OnModelCreating(ModelBuilder builder)
        {
            base.OnModelCreating(builder);

            builder.ApplyConfiguration<AppRole>(new AppRoleCFG());
            builder.ApplyConfiguration<AppUser>(new AppUserCFG());
            builder.ApplyConfiguration<Product>(new ProductCFG());
            builder.ApplyConfiguration<Brand>(new BrandCFG());
            builder.ApplyConfiguration<Category>(new CategoryCFG());
            builder.ApplyConfiguration<Model>(new ModelCFG());
            builder.ApplyConfiguration<Invoice>(new InvoiceCFG());
            builder.ApplyConfiguration<InvoiceDetail>(new InvoiceDetailCFG());
            builder.ApplyConfiguration<ShoppingCart>(new ShoppingCartCFG());
            
            
        }
    }



13. Solutionu rebuild yapıyoruz, hta olup olmadığına bakıyoruz - nuget console açıyoruz, default project infrastructure seçiyoruz, add-migration init dedik 
ve eğer yukarıda bahsi geçen varsayılan constructor u yazmadıysak bu hatayı alıyoruz: Unable to create an object of type HardwareDBContext. For the different patterns supported at design time, see ......
hata yoksa update-database



14. Database den AspNetUsers ve AspNetRoles tablosundaki id kolonları int döndü. 
AspNetUsers tablosundaki PasswordHash gördük
varcharmax kalan ve diğer düzenlenecekler düzenlenebilir.
Değerlerin gelip gelmediğine baktık.



15. Hardware.Infrastructure altında Repositories eklendi.


    public class BaseRepository<T> : IBaseRepository<T> where T :class, IBaseEntity
    {
        private readonly HardwareDBContext _context;
        private readonly DbSet<T> table = null;
        public BaseRepository(HardwareDBContext context)
        {
            _context = context;
            table = context.Set<T>();          //Set diye ayrı bir metot. Geriye DbSet tipinde döndürüyor.
        }
        public async Task AddAsync(T entity)
        {
            entity.CreateDate = DateTime.Now;
            entity.Status = Domain.Enums.Status.Active;
            await table.AddAsync(entity);
            await _context.SaveChangesAsync();
          
        }

        public async Task DeleteAsync(T entity)
        {
            entity.Status = Domain.Enums.Status.Passive;
            entity.PassiveDate = DateTime.Now;
                 
            _context.Entry(entity).State = EntityState.Modified;
            await _context.SaveChangesAsync();
        }

        public async Task<T> FindByIDAsync(int id)
        {
            return await table.FindAsync(id);
        }

        public async Task<T> FindByIDOnlyActiveAsync(int id)
        {
            return await table.Where(x => x.Status == Status.Active).FirstOrDefaultAsync();
        }

        public Task<IQueryable<T>> GetAllAsync()
        {
            return Task.FromResult(table.Select(x => x));
        }
        
        public Task<IQueryable<T>> GetOnlyAllActivesAsync()
        {
            return Task.FromResult(table.Where(x => x.Status == Status.Active).Select(x => x));
        }

        public async Task<int> UpdateAsync(T entity)
        {
            entity.Status = Domain.Enums.Status.Modified;        //sql servere update cümlesi olarak yazacak.
            entity.UpdateDate = DateTime.Now;

            _context.Entry(entity).State = EntityState.Modified;
            _context.Update(entity);
            return await _context.SaveChangesAsync();            //açıklamasında awaitable yazanlarda await kullanılacak.
        }
    }




    // daire, silindir, koni örneğinde; içerde constructorın parametresi varsa silindir oluşturmak istediğimde önce daire oluşuyordu, sonra silindir oluşuyordu.
    //Yani cons arası arametreyi base ile gönderiyorduk.
    //Matruşka gibi sırayla en içerden dışarı doğru çalışır. daire çalıştı, silindir, çalıştı, koni çalıştı yazmıştı. ama biz koniyi oluşturmuştuk.
    //İçerdeki parametre varsa, dışarıdan parametreyi de base ile gönderiyorduk. 
    //İki yöntem vardı; aynı seviyede bir sınıfın constructoruna parametre göndermek için this, üst sınıfa göndermek için base kullanıyorduk.

    public class AppRoleRepository:BaseRepository<AppRole>
    {
        public AppRoleRepository(HardwareDBContext context ):base(context)      //yukarıda bkz migration da özellikle alınan hata konusu
        {
            
        }
    }



    public class AppUserRepository:BaseRepository<AppUser>
    {
        public AppUserRepository(HardwareDBContext context):base(context)
        {
            
        }
    }



    public class BrandRepository:BaseRepository<Brand>,IBrandRepository
    {
        public BrandRepository(HardwareDBContext context):base(context) 
        {
            
        }
    }



    public class CategoryRepository:BaseRepository<Category>,ICategoryRepository
    {
        public CategoryRepository(HardwareDBContext context):base(context) 
        {
            
        }
    }



    public class InvoiceDetailRepository:BaseRepository<InvoiceDetail>,IInvoiceDetailRepository
    {
        public InvoiceDetailRepository(HardwareDBContext context):base(context) 
        {
            
        }
    }



    public class InvoiceRepository:BaseRepository<Invoice>,IInvoiceRepository
    {
        public InvoiceRepository(HardwareDBContext context):base(context)
        {
            
        }
    }



    public class ModelRepository:BaseRepository<Model>,IModelRepository
    {
        public ModelRepository(HardwareDBContext context):base(context) 
        {
            
        }
    }



    public class ProductRepository:BaseRepository<Product>,IProductRepository
    {
        public ProductRepository(HardwareDBContext context):base(context) 
        {
            
        }
    }



    public class ShoppingCartRepository:BaseRepository<ShoppingCart>,IShoppingCartRepository
    {
        public ShoppingCartRepository(HardwareDBContext context):base(context)
        {
            
        }
    }




16. Proje üzerinde sağ tık - add - new project - class library - isimlendirmeye dikkat Hardware.Application - Next - Create
Infrastructure ın görevi veriyi al gönder.
Application da ise işin nasıl yapıldığıyla ilgili kodlar.



17. Katmanların birbirini görmesi için Hardware.Application üzerinde sağ tık - Add - Project Reference - Hardware.Infrastructure tikleyip kaydediyoruz.



18. Hardware.Application altında Services altında klasör açtık.
Dependecy Injection için yaptık.
IOC container e bağlamak için açtık.


Services altında aşağıdaki klasörleri, içlerine de class ve interfacelerini açtık.


--- AppUserService klasörü açtık.
public class AppUserService : IAppUserService
{
        //SignInManager ve UserManager sınıfları MS in sağladığı sınıflar.

        private readonly SignInManager<AppUser> _signInManager;
        private readonly UserManager<AppUser> _userManager;

        //Dependecy Injection gereği yazılan ctor. Constructor Injection yaptık.

        public AppUserService(SignInManager<AppUser> signInManager, UserManager<AppUser> userManager)
        {
            _signInManager = signInManager;
            _userManager = userManager;
        }

        public async Task<bool> LoginAsync(LoginDTO login)
        {
            var user = await _userManager.FindByNameAsync(login.UserName);
            //var user = await _userManager.FindByIdAsync("1");
            //var user = await _userManager.FindByEmailAsync("userRoot@deneme.com");

            var result = await _signInManager.PasswordSignInAsync(user, login.Password, false, false);      //Password hash kontrolünü kendisi yapıyor.

            return result.Succeeded;  
        }

        public async Task LogoutAsync()
        {
            await _signInManager.SignOutAsync();
        }


        //Register ile gelen verileri AppUser a çeviriyoruz. Bunu AutoMapper ile daha kolay yapabiliyoruz. Neyi neyle eşleştireceğiniz söylüyorsunuz o her zaman onları eşleştiriyor. Hoca gösterecek.

        public async Task<bool> RegisterUserAsync(RegisterDTO register)
        {
            AppUser user = new AppUser();

            user.UserName = register.UserName;
            user.FirstName = register.FirstName;
            user.LastName = register.LastName;
            user.Email = register.Email;
            //user.PasswordHash = register.Password;         //Hasher ı koymadan önce şifreyi direk db yazmış. girememiştik. Sistem hash liyi bekliyor. migration silip yeniden oluşturduk sonra
            user.Address = register.Address;
            user.Status = Domain.Enums.Status.Active;
            user.CreateDate = DateTime.Now;

            PasswordHasher<AppUser> password = new PasswordHasher<AppUser>();
            user.PasswordHash = password.HashPassword(user,register.Password);

            var result= await _userManager.CreateAsync(user);    //AppUser istiyor. 

            if(result.Succeeded) {
               await  _signInManager.SignInAsync(user, false);      //persistent yani kalıcı olması : false
               await _userManager.AddToRoleAsync(user, "User");     // "User"   AspNetRoles tablosundaki Name alanından geliyor. Aynı anda birden fazla rol verebilmek için; AddToRolesAsync.
                                                                            //Ya da register başlangıçta olmayıp yönetim panelinden admin tanımlayacak. Kullanıcıya rol seçimi verilemez.
            }

            return result.Succeeded;
        }
    }


    // <bool> yazmamızdaki maksat daha sonra test ettiğimizde çalışıp çalışmadığını anlayabilmek

    public interface IAppUserService
    {
        Task<bool> LoginAsync(LoginDTO login);
        Task LogoutAsync();
        Task<bool> RegisterUserAsync(RegisterDTO register);

    }




--- AppRoleService klasörü açtık.

public class AppRoleService:IAppRoleService
    {
    }

public interface IAppRoleService
    {
    }


--- BrandService klasörü açtık.

    public class BrandService : IBrandService
    {
        private readonly IBrandRepository _brandRepository;
        private readonly IMapper _mapper;

        public BrandService(IBrandRepository brandRepository, IMapper mapper)
        {
            _brandRepository = brandRepository;
            _mapper = mapper;
        }

        public async Task<List<BrandDTO>> GetAllActives()
        {
            var result= await _brandRepository.GetOnlyAllActivesAsync();
            List<BrandDTO> brands = new List<BrandDTO>();
            _mapper.Map(result, brands);
            return brands;
        }
    }

    public interface IBrandService
    {
        Task<List<BrandDTO>> GetAllActives();
    }


--- CategoryService klasörü açtık.

public class CategoryService : ICategoryService
    {
        private readonly ICategoryRepository _categoryRepository;
        private readonly IMapper _mapper;

        public CategoryService(ICategoryRepository categoryRepository, IMapper mapper)
        {
            _categoryRepository = categoryRepository;
            _mapper = mapper;
        }

        public async Task<List<CategoryDTO>> GetAllActives()
        {
           var result = await _categoryRepository.GetOnlyAllActivesAsync();
            List<CategoryDTO> categories= new List<CategoryDTO>();
            _mapper.Map(result, categories);
            return categories;

        }
    }


public interface ICategoryService
    {
        Task<List<CategoryDTO>> GetAllActives();
    }


--- InvoiceDetailService klasörü açtık.

public class InvoiceDetailService:IInvoiceDetailService
    {
    }

public interface IInvoiceDetailService
    {
    }


--- InvoiceService klasörü açtık.

public class InvoiceService:IInvoiceService
    {
    }

public interface IInvoiceService
    {
    }


--- ModelService klasörü açtık.

public class ModelService:IModelService
    {
    }

public interface IModelService
    {
    }


--- ProductService klasörü açtık.

public class ProductService : IProductService
    {
        private readonly IProductRepository _productRepository;
        //private readonly IBrandRepository _brandRepository;
        //private readonly ICategoryRepository _categoryRepository;
        private readonly IMapper _mapper;

        public ProductService(IProductRepository productRepository,
            IMapper mapper)
        {
            _productRepository = productRepository;
            _mapper = mapper;

           

        }

        public async Task<bool> AddProductAsync(ProductDTO product)
        {
           
            Product newProduct = new Product();
           
            _mapper.Map(product, newProduct);
            await _productRepository.AddAsync(newProduct);
            //Islemin basarili olup olmadığı !!!!!
            return false;
        }

        public async Task<bool> DeleteProductAsync(int productID)
        {
            var product = await _productRepository.FindByIDAsync(productID);
            await _productRepository.DeleteAsync(product);
            return true;
        }

        public Task<ProductDetailVM> GetActiveProduct(int productID)
        {
            throw new NotImplementedException();
        }

        public async Task<List<ProductVM>> GetAllOnlyActiveProducts()
        {
            
            var result = _productRepository.GetOnlyAllActivesAsync().Result.Include("Brand").Include("Category").ToList();

            List<ProductVM> products = new List<ProductVM>();

            _mapper.Map(result, products);

            return products;
        }

        public async Task<List<ProductVM>> GetAllProducts()
        {
            var result= _productRepository.GetAllAsync().Result.Include("Brand").Include("Category").ToList();
            List<ProductVM> products = new List<ProductVM>();
           
            _mapper.Map(result, products);

            return products;

        }

        public async Task<ProductDetailVM> GetProduct(int productID)
        {
            throw new NotImplementedException();
        }

        public Task<bool> UpdateProductAsync(ProductDTO product)
        {
            throw new NotImplementedException();
        }
    }


public interface IProductService
    {
        Task<bool> AddProductAsync(ProductDTO product);
        Task<bool> UpdateProductAsync(ProductDTO product);
        Task<bool> DeleteProductAsync(int productID);

        Task<List<ProductVM>> GetAllProducts();
        Task<List<ProductVM>> GetAllOnlyActiveProducts();

        Task<ProductDetailVM> GetProduct(int productID );
        Task<ProductDetailVM> GetActiveProduct(int productID);
    }


--- ShoppingCartService klasörü açtık.

public class ShoppingCartService : IShoppingCartService
    {
        private readonly IShoppingCartRepository _shoppingCartRepository;
        private readonly IMapper _mapper;

        public ShoppingCartService(IShoppingCartRepository shoppingCartRepository, IMapper mapper)
        {
            _shoppingCartRepository = shoppingCartRepository;
            _mapper = mapper;
        }

        public async Task AddProductAsync(ShoppingCartDTO product)
        {
            ShoppingCart shoppingCart = new ShoppingCart();
            _mapper.Map(product, shoppingCart);

            var cart = _shoppingCartRepository.GetOnlyAllActivesAsync().Result.Where(x=>x.ProductID==product.ProductID && x.AppUserID==product.AppUserID).ToList();

            if (cart.Count() == 0)
                await _shoppingCartRepository.AddAsync(shoppingCart);
            else
            {
                var sCart = _shoppingCartRepository.GetOnlyAllActivesAsync().Result.Where(x => x.ProductID == product.ProductID && x.AppUserID == product.AppUserID).SingleOrDefault();
                sCart.ShoppingCartID = shoppingCart.ShoppingCartID;
                sCart.Amount = sCart.Amount + 1;
                await _shoppingCartRepository.UpdateAsync(sCart);
            }
        }

        public async Task<List<ShoppingCartVM>> AllProductsAsync()
        {
            List<ShoppingCartVM> shoppingList = new List<ShoppingCartVM>();
            var result = _shoppingCartRepository.GetOnlyAllActivesAsync()
                                                      .Result.Include("Product");

            _mapper.Map(result, shoppingList);
            return shoppingList;
        }

        public async Task UpdateAmountAsync(int shoppingCartID, int amount)
        {
            var result =  _shoppingCartRepository.FindByIDOnlyActiveAsync(shoppingCartID).Result;
            result.Amount = amount;

            await _shoppingCartRepository.UpdateAsync(result);
        }
    }


public interface IShoppingCartService
    {
        Task AddProductAsync(ShoppingCartDTO product);
        Task<List<ShoppingCartVM>> AllProductsAsync();
        Task UpdateAmountAsync(int shoppingCartID, int amount);

    }




19. Hardware.Application altında Models altında klasör açtık.
Models altında VMs klasörü açtık.
Models altında DTO klasörü açtık. Data Transfer Object katmanlar arasında verileri taşımak için kullanılır. 
Brand entitysinde insert edeceksin mesela, id ye ihtiyaç var mı? İhtiyacın olmayan şeyleri DTO ya yazmazsın. 
Application ile User Interface arasında DTO veri taşıyacak.
Mesela listeleme yapacağım, createdate veya updatedate göndermesine taşımasına gerek yok.

Entity üzerinden değil DTO üzerinden, güvenlik, daha az alanda taşınıyor, performans.
Ön yüzcünün bilmemesi gereken bilgiyi göndermemeliyiz.
Genellikle hepsi için yazılıyor.

Farkları;
VM eğer select cümleleri varsa yani joinlemeniz gerekiyorsa bazı şeyleri o zaman VM
DTO genellikle insert ve update de kullanılır. Sadece ihtiyacı olan verileri kullanacak, gönderecek.

//DTO ları daha önce Insert ve Update için kullanırız demiştik. Burada Select içinde kullanılacak.
//Burada kullanıcı adı ve şifre olarak belirledik. Buna AspNetUsers tablosunun Indexes klasörü altında UserName Unique olduğu için.
//AspNetUsers tablosunu açtık. Kullanıcı login olması için diğer alanların hiçbirisiyle işimiz yok. Bu yüzden AspUser nesnesi kullanmak yerine DTO kullandık. DTO burada select olarak kullandık.
//VM leri genelde joinli yapılarda kullanırız.

Models altında DTO klasörü açmıştık. Onun Altına Login klasörü açtık.

public class LoginDTO
    {
        public string UserName { get; set; }
        public string Password { get; set; }      //arkada hashlenmiş halinin karşılaştırmasını yapacağız.
    }


//Bir kullanıcıyı kaydetmek istediğimde ihtiyacım olan alanlar; AspNetUsers tablosuyla karşılaştırarak değerlendirdik.

public class RegisterDTO
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public string Address { get; set; }
        public string UserName { get; set; }
        public string Password{ get; set; }
        public string ConfirmPassword{ get; set; }
        public string Email{ get; set; }

    }


DİKKAT!!! AspNetUsers tablosuna BaseEntity alanlar gelmemişti. Hoca nugetten komut girerken dikkat. default project Infrastructure seçilmeli. HardwareDbContext sayfası üzerinde olunması gerekiyor.
drop-database ve remove-migration yaptık ve add migration init ve update-database yaptık.
Sonuçta hem AspNetUsers hem de AspNetRoles tabloları başlarına eklendi alanlar.
Ayrıca AspNetUsers tablosunda yeni kullanıcıyı da oluşturmuş.



20. Ağacın en tepesinde sağ tık - Add - New Project - ASP.NET Core Web App (MVC) - Hardware.UI ismini verdik - .NET 6.0 , authentication type : none , configure klikli, enable kliksiz , do not kliksiz - create


21. Katmanların birbirini görmesi için Hardware.UI üzerinde sağ tık - Add - Project Reference - Hardware.Application tikleyip kaydediyoruz.


22. appsettings.json içine querystring ekleyecekti ama eklemedi infrasturcture da tanımlı olduğundan. Deneyelim dedi.


23. Program.cs içerisine aşağıdaki eklemeleri yaptık;



// Add services to the container.
builder.Services.AddControllersWithViews();

-------İLE


//Context sınıfı ile ilgili ayarları yap...

//ZATEN INFRASTRUCTURE KATMANINDA CONNECTION BİLGİSİNİ VERMİŞTİK. O YÜZDEN BUNU KAPATTIK.
//builder.Services.AddDbContext<HardwareDBContext>(x => x.UseSqlServer(
//    builder.Configuration.GetConnectionString("ConnStr")
//    ));

builder.Services.AddDbContext<HardwareDBContext>(x => x.UseSqlServer());


//Standart Identity kullanımının dışına çıktığımız için;

builder.Services.AddIdentity<AppUser, AppRole>(x => {

    //BU ARAYA FARKLI ÖZELLİKLER EKLENEBİLİR. LOGIN-LOGOUT-REGISTER KONULARINDA

    x.Password.RequiredLength = 7;
    
}).AddEntityFrameworkStores<HardwareDBContext>();



builder.Services.AddAutoMapper(x => x.AddProfile(typeof(HardwareMapper)));



//IoC =>Inversion Of Control...

//Gerektikce ekle...
builder.Services.AddTransient<IProductRepository, ProductRepository>();
builder.Services.AddTransient<ICategoryRepository, CategoryRepository>();
builder.Services.AddTransient<IBrandRepository, BrandRepository>();
builder.Services.AddTransient<IShoppingCartRepository, ShoppingCartRepository>();

builder.Services.AddTransient<IAppUserService, AppUserService>();
builder.Services.AddTransient<IBrandService, BrandService>();
builder.Services.AddTransient<ICategoryService, CategoryService>();

builder.Services.AddTransient<IProductService, ProductService>();
builder.Services.AddTransient<IShoppingCartService, ShoppingCartService>();

--------------------ARASINA


var app = builder.Build();




ve 




app.UseAuthentication();


-----------------------ÜSTÜNE
app.UseAuthorization();
//eklemeyi unutma....








AddTransient : Ramde yaşam süresi en kısa olan
AddScoped : 
AddSingleton : 





24. Hardware.UI üzerinde sağ tık - Add - New Scaffolded Item - MVC Area - Create - AdminPanel ismi verdik - Add


25. Hardware.UI üzerinde sağ tık - Add - New Scaffolded Item - MVC Area - Create - UserPanel ismi verdik - Add


26. Kendi oluşan aşağıdaki kodu kopyalayıp program.cs içinde aşağıdaki yere yapıştırıyoruz. Kaç Area oluşrsa olsun bu işlemi bir defa yapıyoruz.

app.UseEndpoints(endpoints =>
        {
          endpoints.MapControllerRoute(
            name : "areas",
            pattern : "{area:exists}/{controller=Home}/{action=Index}/{id?}"
          );
        });




app.UseAuthorization();
//eklemeyi unutma....

--------------------------İLE

app.UseEndpoints(endpoints =>
{
    endpoints.MapControllerRoute(
      name: "areas",
      pattern: "{area:exists}/{controller=Home}/{action=Index}/{id?}"
    );
});


--------------------------ARASINA

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

app.Run();







27. Areas - AdminPanel - Controllers üzerinde sağ tık - Add - Controller - Empty - Add - PanelController adını verdik - Add

[Area("AdminPanel")]
    public class PanelController : Controller
    {
        public IActionResult Index()
        {
            return View();
        }
    }


28. AdminPanel - PanelController içindeki Index aksiyonu/metodu üzerinden sağ tık - Add View - Empty - Add - Index.cshtml adını verdik - Add

<h1>Admin Panel...</h1>



29. Areas - UserPanel - Controllers üzerinde sağ tık - Add - Controller - Empty - Add - PanelController adını verdik - Add

[Area("UserPanel")]
    public class PanelController : Controller
    {
        public IActionResult Index()
        {
            return View();
        }
    }



30. UserPanel - PanelController içindeki Index aksiyonu/metodu üzerinden sağ tık - Add View - Empty - Add - Index.cshtml adını verdik - Add

<h1>User Panel...</h1>




31. Login ekranı için ana Controllers üzerinde sağ tık - Add - Controller - Empty - Add - LoginController adını verdik - Add

//Diikat!!! Artık iş hesaplamaları servislerin içerisinde. Burada sadece veriyi al kontrol et ve gönder kısmı var.

public class LoginController : Controller
    {
        
        private readonly IAppUserService _appUserService;
        private readonly UserManager<AppUser> _userManager;
        private readonly SignInManager<AppUser> _signInManager;

        public LoginController(IAppUserService appUserService,UserManager<AppUser> userManager,SignInManager<AppUser> signInManager)
        {
            _appUserService=appUserService;
            _userManager=userManager;
            _signInManager=signInManager;
        }

        
        public async Task<IActionResult> Login()
        {
            return View();
        }



        [HttpPost]
        public async Task<IActionResult> Login(LoginDTO login)
        {
            //return Content(login.UserName + " " + login.Password);
            var result = await _appUserService.LoginAsync(login);

            //Kullanıcı Admin se admin sayfasında, user sa user sayfasına yönlendirme işlemi için kullanıcının rolünü görme
            if (result)
                return Content("login islemi basarili..." + User.IsInRole("User") + User.Identity.Name);
            else
                return Content("hatalı giris...");
        }



        public IActionResult LogOut()
        {
            return View();
        }



        public IActionResult Register()
        {
            return View();
        }


        [HttpPost]
        public async Task<IActionResult> Register(RegisterDTO register)
        {
            var result= await _appUserService.RegisterUserAsync(register);
            if (result)
                return Content("olustu...");
            else
                return Content("hata  var...");
        }
    }





32. Ana Controller altındaki LoginController içindeki Login aksiyonu/metodu üzerinden sağ tık - Add View - Empty - Add - Login.cshtml adını verdik - Add
Scaffold yaptık ama çalışmadı.

@using Hardware.Application.Models.DTOs.Login;
@model LoginDTO;

<form asp-action="Login" method="post">
    <table class="table table-striped">
        <tr>
            <td>
                User Name:
            </td>
            <td>
                <input type="text" asp-for="UserName"  class="form-control"/>
            </td>
            </tr>
            <tr>
            <td>
                Password:
            </td>
            <td>
                <input type="password" asp-for="Password" class="form-control" />
            </td>
            </tr>
            <tr>
            <td colspan="2">
              <input type="submit"  value="Login"/>
            </td>
        </tr>
    </table>
</form>



//KATMANSIZ PROJEDE SCAFFOLD YAPIP BURAYA ATILABİLİR. YÖNTEMLERDEN BİRİ. DATABASE FIRST YAKLAŞIMI İLE. ÖNCE PROJEDE MIGRATION YAPIP DATABASE OLUŞTURUP SONRA VAR OLAN DB ÜZERİNDEN DATABASE FIRST İLE İKİNCİ PROJE OLUŞTURULABİLİR.



33. Ana Controller altındaki LoginController içindeki Register aksiyonu/metodu üzerinden sağ tık - Add View - Empty - Add - Register.cshtml adını verdik - Add

@using Hardware.Application.Models.DTOs.Login;
@model RegisterDTO;

<form asp-action="Register" method="post">
    <table class="table table-striped">
        <tr>
            <td>
                <label asp-for="FirstName"></label>
            </td>
            <td>
                <input type="text" asp-for="FirstName" class="form-control" />
            </td>
        </tr>
        <tr>
            <td>
                <label asp-for="LastName"></label>
            </td>
            <td>
                <input type="text" asp-for="LastName" class="form-control" />
            </td>
        </tr>
        <tr>
            <td>
                <label asp-for="Address"></label>
            </td>
            <td>
                <input type="text" asp-for="Address" class="form-control" />
            </td>
        </tr>
        <tr>
            <td>
                <label asp-for="UserName"></label>
            </td>
            <td>
                <input type="text" asp-for="UserName" class="form-control" />
            </td>
        </tr>
        <tr>
            <td>
                <label asp-for="Email"></label>
            </td>
            <td>
                <input type="text" asp-for="Email" class="form-control" />
            </td>
        </tr>
        <tr>
            <td>
                <label asp-for="Password"></label>
            </td>
            <td>
                <input type="password" asp-for="Password" class="form-control" />
            </td>
        </tr>
        <tr>
            <td>
                <label asp-for="ConfirmPassword"></label>
            </td>
            <td>
                <input type="password" asp-for="ConfirmPassword" class="form-control" />
            </td>
        </tr>
        <tr>
            <td colspan="2">
                <input type="submit" value="Register User" />
            </td>
        </tr>
    </table>
</form>



34. Projeyi çalıştırıp kullanıcı oturum açılması ve kullanıcı eklenmesi konuları test edildi.



35. Role tablosuna Admin rolü verisi gelmiyordu. O düzeltildi.

protected override void OnModelCreating(ModelBuilder builder)
{

içine

 //İlk user'a Admin yetkisi vermek için...
builder.Entity<IdentityUserRole<int>>().HasData( new IdentityUserRole<int> { UserId=1, RoleId=1 });

ekledik.

drop-database
remove-migration
add-migration init
update-database



36. Programı çalıştırdık ve registerden kullanıcı oluşturacaktık. Şifre konusunda sorun oluştu, yukarıda düzeltmesini yaptık ve oluşturduk, db den user tablosundan hash kontrol ettik.
Çalıştırırken dikkat.
Login Controller ekranda açıkken çalıştır veya hata verirse farklı ekranları dene.


37. UI katmanı içindeki Views içindeki _ViewImports ve _ViewStart dosyalarını kopyalayıp, 
Areas - AdminPanel - Views ve
Areas - UserPanel - Views içine yapıştırıyoruz ve Rebuild yapıyoruz. Layoutun gelmesi için. 


38. Kullanıcı Admin se admin sayfasında, user sa user sayfasına ynlendirme işlemi.
Bunun için öncelikle kitabın girileceği sayfayı yapıyoruz.


Areas - AdminPanel - Views - Panel - Index.cshtml  içine aşağıdakileri ekliyoruz.


<h1>Admin Panel...</h1>

<ul>
    <li><a asp-area="AdminPanel" asp-controller="Product" asp-action="Index">Products</a></li>
</ul>



39. DTO ve VM lerin oluşturulması

39.a DTO ların oluşturulması

Application - Models - DTOs altına Product klasörü açıyoruz. İçine aşağıdaki sınıfı oluşturuyoruz.
    public class ProductDTO
    {
        public int ProductID { get; set; }    //Insert için gerek yok ama update ve delete için gerekli olacağından bıraktık. 
        public string Name { get; set; }

        public int? BrandID { get; set; }
        public int? CategoryID { get; set; }

        public decimal Price { get; set; }
        public int AmountOfStock { get; set; }
        public string ProductImage { get; set; }    //Bunu içeren bir nesneye ihtiyacım olabilir. 
        public string Details { get; set; }
       
    }


Application - Models - DTOs altına Category klasörü açıyoruz. İçine aşağıdaki sınıfı oluşturuyoruz.
    public class CategoryDTO
    {
        public int CategoryID { get; set; }
        public string Name { get; set; }
    }


Application - Models - DTOs altına Brand klasörü açıyoruz. İçine aşağıdaki sınıfı oluşturuyoruz.
    public class BrandDTO
    {
        public int BrandID { get; set; }
        public string Name { get; set; }
    }


Application - Models - DTOs altına ShoppingCart klasörü açıyoruz. İçine aşağıdaki sınıfı oluşturuyoruz.
public class ShoppingCartDTO
    {
        public int ShoppingCartID { get; set; } //UPDATE
        public int ProductID { get; set; }
        public int Amount { get; set; }
        public int AppUserID { get; set; }
    }



39.b 
Application - Models - VMs altına aşağıdaki sınıfları oluşturuyoruz.

    public class ProductVM
    {
        public int ProductID { get; set; }
        public string Name { get; set; }

        public string BrandName { get; set; }
        public string CategoryName { get; set; }

        public decimal Price { get; set; }
       
        public string ProductImage { get; set; }      
    }



    public class ProductDetailVM
    {
        public int ProductID { get; set; }
        public string Name { get; set; }

        public string BrandName { get; set; }
        public string CategoryName { get; set; }

        public decimal Price { get; set; }
        public int AmountOfStock { get; set; }        //bunları detayda gösterdik.
        public string ProductImage { get; set; }
        public string Details { get; set; }           //bunları detayda gösterdik. 
    }




    public class ShoppingCartVM
    {
        public int ShoppingCartID { get; set; } 
        public int ProductID { get; set; }
        public string Name { get; set; }
        public decimal Price { get; set; }
        public int Amount { get; set; }
        public int AppUserID { get; set; }
    }



40. AutoMapper kullanımı
Register içerisinde eşleştirme yaparken AutoMapper kullanmadık, uzadı. 
Automapper da isimler aynıysa kendi eşleştiriyor, farklıysa biz hangisinin hangisiyle bağlanacağını tanımlıyoruz.

40.a Tools - Nuget - browse - automapper arat - AutoMapper.Extensions.Microsoft.DependencyInjection seç - HardwareApplication klikle - 12.0.1 versiyon - Install

40.b Hardware.Application üzerinde sağ tık - Add - New Folder - AutoMapper klasörü oluştur ve içerisine de aşağıdaki sınıfı oluştur. Çünkü servisler bu katmanda.

public class HardwareMapper:Profile
    {
        public HardwareMapper()
        {
            CreateMap<Product, ProductDTO>().ReverseMap();      //Tersten de gelse bağla demek.
            
            CreateMap<Product, ProductVM>()
                .ForMember(x=>x.BrandName,y=>y.MapFrom(y=>y.Brand.Name)).ForMember(x=>x.CategoryName,y=>y.MapFrom(y=>y.Category.Name)).ReverseMap();

            CreateMap<Category,CategoryDTO>().ReverseMap();
            CreateMap<Brand,BrandDTO>().ReverseMap();

            CreateMap<ShoppingCart,ShoppingCartDTO>().ReverseMap();
            CreateMap<ShoppingCart, ShoppingCartVM>()
                .ForMember(x=>x.Name, y=>y.MapFrom(y=>y.Product.Name))
                .ForMember(x=>x.Price, y=>y.MapFrom(y=>y.Product.Price))
                .ReverseMap();
        }
    }


40.c Program.cs içine IOC üstüne aşağıdaki kodu ekledik.
builder.Services.AddAutoMapper(x => x.AddProfile(typeof(HardwareMapper)));





41. Hardware.Application - Services - ProductService içerisindeki interface ve sınıfları doldurduk.

   

42. Hardware.Application - Services - CategoryService içerisindeki interface ve sınıfları doldurduk.



43. Hardware.Application - Services - BrandService içerisindeki interface ve sınıfları doldurduk.



44. Hardware.UI - Areas - AdminPanel - Controller - sağ tık Add - Controller - Empty - ProductController adını verdik - 
Scaffold çalışsaydı ProductDTO üzerinden yapacaktık.

[Area("AdminPanel")]
    public class ProductController : Controller
    {
        private readonly IProductService _productService;
        private readonly ICategoryService _categoryService;
        private readonly IBrandService _brandService;

        public ProductController(IProductService productService, ICategoryService categoryService, IBrandService brandService)
        {
            _productService = productService;
            _categoryService = categoryService;
            _brandService = brandService;
        }

        public async Task<IActionResult> Index()
        {


            return View(await _productService.GetAllOnlyActiveProducts());    //BU VM GÖNDERECEK.
        }

        public async Task<IActionResult> AddProduct()
        {
            ViewBag.Brands = new SelectList(await _brandService.GetAllActives(), "BrandID", "Name");
            ViewBag.Categories = new SelectList(await _categoryService.GetAllActives(), "CategoryID", "Name");
            return View();
        }

        [HttpPost]
        public async Task<IActionResult> AddProduct(ProductDTO product, IFormFile file)
        {
            product.ProductImage = file.FileName;

            string strFilePath = "wwwroot\\Resimler\\" + file.FileName;
            FileStream fs = new FileStream(strFilePath, FileMode.Create);
            await file.CopyToAsync(fs);
            fs.Close();
            await _productService.AddProductAsync(product);
            return RedirectToAction("Index");
        }

        public async Task<IActionResult> DeleteProduct(int id)
        {
            await _productService.DeleteProductAsync(id);

            return Content("urun Silindi...");
        }
    }


45. Yukarıdaki controllerdaki aksiyon adı üzerinden sağ tık - sdd view - AddProduct.cshtml oluşturduk.


@using Hardware.Application.Models.DTOs.Product;
@model ProductDTO

<form asp-area="AdminPanel" asp-controller="Product" asp-action="AddProduct" method="post" enctype="multipart/form-data">
    <table class="table table-striped">
        <tr>
            <td>
                <label asp-for="Name" class="form-control"></label>
            </td>
            <td>
                <input type="text"  asp-for="Name" class="form-control"/>
            </td>
        </tr>
        <tr>
            <td>
                <label asp-for="BrandID" class="form-control"></label>
            </td>
            <td>
                <select  asp-for="BrandID" class="form-control" asp-items="@ViewBag.Brands" >
                </select>
            </td>
        </tr>
        <tr>
            <td>
                <label asp-for="CategoryID" class="form-control"></label>
            </td>
            <td>
                <select asp-for="CategoryID" class="form-control" asp-items="@ViewBag.Categories">
                </select>
            </td>
        </tr>
        <tr>
            <td>
                <label asp-for="Price" class="form-control"></label>
            </td>
            <td>
                <input type="number" asp-for="Price" class="form-control" />
            </td>
        </tr>
        <tr>
            <td>
                <label asp-for="AmountOfStock" class="form-control"></label>
            </td>
            <td>
                <input type="number" asp-for="AmountOfStock" class="form-control" />
            </td>
        </tr>
        <tr>
            <td>
                <label asp-for="ProductImage" class="form-control"></label>
            </td>
            <td>
                <input type="hidden" asp-for="ProductImage" class="form-control" value="empty.jpg ">
                <input type="file" name="file" class="form-control" />
            </td>
        </tr>
        <tr>
            <td>
                <label asp-for="Details" class="form-control"></label>
            </td>
            <td>
                <textarea asp-for="Details" class="form-control" rows="5" cols="60" >
                </textarea>
            </td>
        </tr>
        <tr>
           
            <td colspan="2">
                <input type="submit" class="btn btn-primary" value="Add a Product" />
            </td>
        </tr>
    </table>
</form>





46. Yukarıdaki controllerdaki aksiyon adı üzerinden sağ tık - sdd view - Index.cshtml oluşturduk.

@using Hardware.Application.Models.VMs;
@model IEnumerable<ProductVM>

    <a asp-area="AdminPanel" asp-controller="Product" asp-action="AddProduct" >Add new Product</a>
<br />

<table>
@foreach(var item in Model)
{
    <tr>
        <td>
                @item.ProductID
        </td>
            <td>
                @item.Name
            </td>
            <td>
                <a class="btn btn-danger" asp-area="AdminPanel" asp-controller="Product" asp-action="DeleteProduct" asp-route-id="@item.ProductID">Delete</a>
            </td>
    </tr>

    

}
</table>



47. Program çalıştırıldı ve ürün ekleme işlemi yapıldı.


48. Yukarıdaki Index sayfasını herkes göreceğinden kendimize göre özelleştirdik. 

    public class HomeController : Controller
    {
        private readonly IProductService _productService;

        public HomeController(IProductService productService)
        {
            _productService = productService;
        }

        public async Task<IActionResult> Index()
        {
            //Tum urunleri sayfada goster

            return View(await _productService.GetAllOnlyActiveProducts());
        }

        public IActionResult Privacy()
        {
            return View();
        }

        [ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
        public IActionResult Error()
        {
            return View(new ErrorViewModel { RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier });
        }
    }


49. Home un Indexini düzenledik.

@inject SignInManager<AppUser> _signInManager    //RAZOR INJECTION

@using Hardware.Application.Models.VMs;
@using Hardware.Domain.Entities.Concrete;
@using Microsoft.AspNetCore.Identity;
@model IEnumerable<ProductVM>



@foreach (var item in Model)
{
    <table>
        <tr>
            <td>
                <img src="~/Resimler/@item.ProductImage" width="140" height="110" />
            </td>
            <td>
                @item.Name
            </td>
            <td>
                @item.BrandName
            </td>
            <td>
                @item.CategoryName
            </td>
            <td>
                @item.Price
            </td>
            <td>
                @if(_signInManager.IsSignedIn(User))    //DİKKAT!!! KULLANICI OTURUM AÇMADIYSA BUTONU GÖRMEZ.
                {
                <a class="btn btn-secondary" asp-area="UserPanel" asp-controller="ShoppingCart" asp-action="AddToCart" asp-route-id="@item.ProductID">Add to Cart </a>
                }
                
            </td>
        </tr>
    </table>
  
}



50. Areas - UserPanel - Controllers içine aşağıdaki controlleri ekledik.

[Area("UserPanel")]
    public class ShoppingCartController : Controller
    {

        private readonly IShoppingCartService _shoppingCartService;
        private readonly UserManager<AppUser> _userManager;

        public ShoppingCartController(IShoppingCartService shoppingCartService, UserManager<AppUser> userManager)
        {
            _shoppingCartService = shoppingCartService;
            _userManager = userManager;
        }



        //public IActionResult Index()
        //{
        //    return View();
        //}


        public async Task<IActionResult> AddToCart(int id)
        {
            ShoppingCartDTO shoppingDTO = new ShoppingCartDTO();
            shoppingDTO.ProductID = id;
            shoppingDTO.Amount = 1;
            shoppingDTO.AppUserID = GetUserID();
            await _shoppingCartService.AddProductAsync(shoppingDTO);
            return NoContent();

        }

        private int GetUserID()
        {
            return  _userManager.GetUserAsync(User).Result.Id;
        }
    }








